= sso 单点登录
:imagesdir: ./images
:iconsdir: ./images/icons

SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。

== 实现机制
当用户第一次访问应用系统1的时候，因为还没有登录，会被引导到认证系统中进行登录；根据用户提供的登录信息，认证系统进行身份校验，如果通过校验，应该返回给用户一个认证的凭据－－ticket；用户再访问别的应用的时候就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行校验，检查ticket的合法性。如果通过校验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。
要实现SSO，需要以下主要的功能：

系统共享::
统一的认证系统是SSO的前提之一。认证系统的主要功能是将用户的登录信息和用户信息库相比较，对用户进行登录认证；认证成功后，认证系统应该生成统一的认证标志（ticket），返还给用户。另外，认证系统还应该对ticket进行校验，判断其有效性。

信息识别::
要实现SSO的功能，让用户只登录一次，就必须让应用系统能够识别已经登录过的用户。应用系统应该能对ticket进行识别和提取，通过与认证系统的通讯，能自动判断当前用户是否登录过，从而完成单点登录的功能。

== 主要实现技术
基于cookies实现::
如果是基于两个域名之间传递sessionid的方法可能在windows中成立，在unix&linux中可能会出现问题;可以基于数据库实现；在安全性方面可能会作更多的考虑。另外，关于跨域问题，虽然cookies本身不跨域，但可以利用它实现跨域的SSO。

Broker-based（基于经纪人）::
这种技术的特点就是，有一个集中的认证和用户帐号管理的服务器。经纪人给被用于进一步请求的电子的身份存取。

Agent-based（基于代理人）::
在这种解决方案中，有一个自动地为不同的应用程序认证用户身份的代理程序。这个代理程序需要设计有不同的功能。比如，它可以使用口令表或加密密钥来自动地将认证的负担从用户移开。代理人被放在服务器上面，在服务器的认证系统和客户端认证方法之间充当一个"翻译"。例如SSH等。

Token-based::
例如SecurID,WebID，现在被广泛使用的口令认证，比如FTP,邮件服务器的登录认证，这是一种简单易用的方式，实现一个口令在多种应用当中使用。

 基于安全断言标记语言（SAML）实现::
 SAML(Security Assertion Markup Language，安全断言标记语言）的出现大大简化了SSO，并被OASIS批准为SSO的执行标准。开源组织OpenSAML 实现了 SAML 规范。

== 现有实现设计
实现方式::
目前在现在的系统中，采用了基于 _cookies_ 的实现，在多个系统中使用 _cookie_ 来传输票据。


单点登录实现的要点在于将认证中心进行统一，在所有系统之上构建一个唯一的认证中心即可。如下图，多系统之间的访问，票据认证应该全部在统一认证中心完成。

.访问示意图
image::sso.png[]

然而在面临多系统之间，不同的用户体系footnote:[指用户信息不一致，角色权限不一致的情况]时，如果还继续将用户的校验放在 _dmcas_ 统一认证中心完成，那么将无法完成多系统不同用户之间的集成。

此时的结构应该如下图，各子系统独立完成自己的用户检验，角色权限控制。 *_dmcas_ 只应该存储票据与信任列表，进行票据校验即可*。此时 _dmcas_ 在中间还应 *协调* 完成各子系统的 *用户匹配*，具体如何 *匹配* 还是由子系统决定， _dmcas_ 在中间充当一个 *调度者* 的角色。

这种结构就决定了 _dmcas_ 与子系统之间只需要依赖公共接口，通过 _rpc_ 调用完成。

.多系统之间认证
image::sso-cross.png[]


include::dmcas.asciidoc[]

include::dmcas-client.asciidoc[]

include::dmcas-validation.asciidoc[]
