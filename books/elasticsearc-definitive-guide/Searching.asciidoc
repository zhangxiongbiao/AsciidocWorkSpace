= 基本搜索

._ES_ 可以做以下的搜索
. 结构化查询，如根据某一字段 _gender_ 或 _age_ 查询，然后再根据字段 _join date_ 排序。
. 全文查询，找到所有匹配关键字的文档，并按相关度进行排序
. 上述二者结合查询

为了更深入的了解 _search_ ，你需要了解以下几个模块。

Mapping::
在每一个字段中数据是如何存储或解释的

Analysis::
全文是如何被处理并可搜索的

Query DSL::
_Elasticsearch_ 使用到的强大的查询语言，就像数据库中有 _SQL_ 作为查询语言一样。

本章只对上述三个模块作简短介绍，更深入的在 _Search in depth_

== 无请求体的检索

[source,js]
----
GET /_search
----

响应信息如下：

[source,js]
----
{
   "hits" : {
      "total" :       14,
      "hits" : [
        {
          "_index":   "us",
          "_type":    "tweet",
          "_id":      "7",
          "_score":   1,
          "_source": {
             "date":    "2014-09-17",
             "name":    "John Smith",
             "tweet":   "The Query DSL is really powerful and flexible",
             "user_id": 2
          }
       },
        ... 9 RESULTS REMOVED ...
      ],
      "max_score" :   1
   },
   "took" :           4,
   "_shards" : {
      "failed" :      0,
      "successful" :  10,
      "total" :       10
   },
   "timed_out" :      false
}
----

=== hits
上述最重要的就是 _hits_ ，它包含了所有匹配的文档，其下的 _hits_ 数组包含了前10个匹配到的文档。

在 _hits_ 数组中的每一个结果都包含 `_index` , `_type`, `_id` 及 `_source` 。这里 _ES_ 直接把结果数据给返回了，在其它的搜索引擎中，可能先只会返回 _document id_ ，然后再让你根据 _document id_ 去拿数据。

每一个结果也有一个 `_score` ，它表示文档匹配的相关度分数。结果中的数据默认是按 `_score` 倒序排的。

=== took
表示执行这次检索请求的耗时，单位为 _ms_

=== shards
`_shards` 在告诉我们这次请求在多少个分片（  `total`  ）上进行了检索。 `failed` 表示有多少个分片执行检索失败了， `successful` 表示有多少个分片执行检索成功了。

通常我们不希望会出现分片执行失败的情况，然而当我们的主、备分片都丢失时，该分片上的检索将会 `failed` ，当然这不会影响同一请求在其它分片上的检索。

=== timeout
`timeout` 用于告诉我们请求是否超时了。默认情况下，查询请求是不会超时的（会一直等待下去）。如果对你而言响应时间比完整的结果更重要的话，那么你可以在查询请求后面加上 _timeout_ 参数，如 timeout=10ms 或 timeout=5s

[source,js]
----
GET /_search?timeout=300ms
----

_ES_ 会在响应超时前，将所有已经收集到的结果返回。

[CAUTION]
====
_timeout_ 参数并不会中断查询请求，它只是告诉协调节点（你的客户端连接的节点）在超时时间内把已经收集到的结果给返回并且关闭连接。然而未收集到的结果，那些未在超时时间内完成检索的分片上的检索请求还是会继续，哪怕协调节点已经关闭把结果给返回了。

当你关心你的系统的响应时间时，你才需要用 _timeout_ ，而不是说你想中止查询请求。
====


== 多索引，多类型

_ES_ 可以在整个集群中进行搜索，即跨索引、跨类型进行搜索。

`/_search`::
在所有的索引及其下所有的类型中搜索

`/gb/_search`::
在索引 `gb` 下的所有类型中搜索

`/gb,us/_search`::
在索引 `gb` 与 `us` 下的所有类型中搜索

`/g*,u*/_search`::
在以 `g` 或  `u` 开头的索引下的所有类型中搜索

`/gb/user/_search`::
在索引 `gb` 下的 `user` 类型中搜索

`/gb,us/user,tweet/_search`::
在索引 `gb` 或 `us` 下的 `user` 或 `tweet` 类型下搜索

`/_all/user,tweet/_search`::
在所有索引下的 `user` 或 `tweet` 类型下搜索

== 分页
from::
默认值为0
size::
每页的大小，默认为10

[source,js]
----
GET /_search?size=5
GET /_search?size=5&from=5
GET /_search?size=5&from=10
----

分页检索时，要避免 _from_ 太大，或者 _size_ 太大，因为结果是要在返回前进行排序的。注意检索请求是会跨越多个分片的，每一个分片返回它的排序结果，然后再由协调节点集中对所有结果进行排序并返回指定结果给客户端。

.深入分布式系统分页
****
为了理解为什么深度分页是有问题的，让我们假设在一个有5个主分片的索引中搜索。当我们请求结果的第一页（结果1到10）时，每个分片产生自己最顶端10个结果然后返回它们给请求节点(requesting node)，它再排序这所有的50个结果以选出顶端的10个结果。

[red]#现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！#

你可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长。这也是为什么网络搜索引擎中任何语句不能返回多于1000个结果的原因。
****

== 简单搜索
查询字符串很方便在命令行查询时使用。

[blue]##查询字符串搜索对于在命令行下运行点对点(ad hoc)查询特别有用。例如这个语句查询所有类型为tweet并在tweet字段中包含elasticsearch字符的文档：##
[source,js]
----
GET /_all/tweet/_search?q=tweet:elasticsearch
----

下一个语句查找name字段中包含"john"和tweet字段包含"mary"的结果。实际的查询只需要：
[source,js]
----
+name:john +tweet:mary
----

"+"前缀表示语句匹配条件必须被满足。类似的"-"前缀表示条件必须不被满足。所有条件如果没有+或-表示是可选的——匹配越多，相关的文档就越多。

且(+)、或( )、非(-)

=== _all字段

返回包含"mary"字符的所有文档的简单搜索：
[source,js]
----
GET /_search?q=mary
----

在前一个例子中，我们搜索tweet或name字段中包含某个字符的结果。然而，这个语句返回的结果在三个不同的字段中包含"mary"：

. 用户的名字是“Mary”
. “Mary”发的六个推文
. 针对“@mary”的一个推文

Elasticsearch是如何设法找到三个不同字段的结果的？

当你索引一个文档，[red]#Elasticsearch把所有字符串字段值连接起来放在一个大字符串中，它被索引为一个特殊的字段_all#。例如，当索引这个文档：

[source,json]
----
{
    "tweet":    "However did I manage before Elasticsearch?",
    "date":     "2014-09-14",
    "name":     "Mary Jones",
    "user_id":  1
}
----

这好比我们增加了一个叫做_all的额外字段值：

[source,js]
----
"However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1"
----

查询字符串在未明确指定搜索哪个字段时，使用 _all 作为默认检索的字段。

== 更复杂的查询语句

.搜索语句
. _name_ 字段包含 _mary_ 或 _john_
. _date_ 大于 _2014-09-10_
. `_all` 字段包含 _aggregations_ 或 _geo_

[source,js]
----
+name:(mary john) +date:>2014-09-10 +(aggregations geo)
----

就像你上面看到的例子，简单(lite)查询字符串搜索惊人的强大。它的查询语法，会在《查询字符串语法》章节阐述。参考文档允许我们简洁明快的表示复杂的查询。这对于命令行下一次性查询或者开发模式下非常有用。


然而，你可以看到简洁带来了隐晦和调试困难。而且它很脆弱——查询字符串中一个细小的语法错误，像-、:、/或"错位就会导致返回错误而不是结果。


最后，查询字符串搜索允许任意用户在索引中任何一个字段上运行潜在的慢查询语句，可能暴露私有信息甚至使你的集群瘫痪。

[TIP]
====
因为这些原因，我们不建议直接暴露查询字符串搜索给用户，除非这些用户对于你的数据和集群可信。
====

通常，应该使用 _Query DSL_ 来代替查询字符串，它更强大。在了解 _Query DSL_ 之前，还需要了解下数据如何在 _ES_ 中存储的。
