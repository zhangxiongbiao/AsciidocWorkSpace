<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>The Elasticsearch Definitive Guide</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */
/* ========================================================================== HTML5 display definitions ========================================================================== */
/** Correct `block` display not defined in IE 8/9. */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }

/** Correct `inline-block` display not defined in IE 8/9. */
audio, canvas, video { display: inline-block; }

/** Prevent modern browsers from displaying `audio` without controls. Remove excess height in iOS 5 devices. */
audio:not([controls]) { display: none; height: 0; }

/** Address `[hidden]` styling not present in IE 8/9. Hide the `template` element in IE, Safari, and Firefox < 22. */
[hidden], template { display: none; }

script { display: none !important; }

/* ========================================================================== Base ========================================================================== */
/** 1. Set default font family to sans-serif. 2. Prevent iOS text size adjust after orientation change, without disabling user zoom. */
html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ }

/** Remove default margin. */
body { margin: 0; }

/* ========================================================================== Links ========================================================================== */
/** Remove the gray background color from active links in IE 10. */
a { background: transparent; }

/** Address `outline` inconsistency between Chrome and other browsers. */
a:focus { outline: thin dotted; }

/** Improve readability when focused and also mouse hovered in all browsers. */
a:active, a:hover { outline: 0; }

/* ========================================================================== Typography ========================================================================== */
/** Address variable `h1` font-size and margin within `section` and `article` contexts in Firefox 4+, Safari 5, and Chrome. */
h1 { font-size: 2em; margin: 0.67em 0; }

/** Address styling not present in IE 8/9, Safari 5, and Chrome. */
abbr[title] { border-bottom: 1px dotted; }

/** Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */
b, strong { font-weight: bold; }

/** Address styling not present in Safari 5 and Chrome. */
dfn { font-style: italic; }

/** Address differences between Firefox and other browsers. */
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }

/** Address styling not present in IE 8/9. */
mark { background: #ff0; color: #000; }

/** Correct font family set oddly in Safari 5 and Chrome. */
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }

/** Improve readability of pre-formatted text in all browsers. */
pre { white-space: pre-wrap; }

/** Set consistent quote types. */
q { quotes: "\201C" "\201D" "\2018" "\2019"; }

/** Address inconsistent and variable font size in all browsers. */
small { font-size: 80%; }

/** Prevent `sub` and `sup` affecting `line-height` in all browsers. */
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }

sup { top: -0.5em; }

sub { bottom: -0.25em; }

/* ========================================================================== Embedded content ========================================================================== */
/** Remove border when inside `a` element in IE 8/9. */
img { border: 0; }

/** Correct overflow displayed oddly in IE 9. */
svg:not(:root) { overflow: hidden; }

/* ========================================================================== Figures ========================================================================== */
/** Address margin not present in IE 8/9 and Safari 5. */
figure { margin: 0; }

/* ========================================================================== Forms ========================================================================== */
/** Define consistent border, margin, and padding. */
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }

/** 1. Correct `color` not being inherited in IE 8/9. 2. Remove padding so people aren't caught out if they zero out fieldsets. */
legend { border: 0; /* 1 */ padding: 0; /* 2 */ }

/** 1. Correct font family not being inherited in all browsers. 2. Correct font size not being inherited in all browsers. 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */
button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ }

/** Address Firefox 4+ setting `line-height` on `input` using `!important` in the UA stylesheet. */
button, input { line-height: normal; }

/** Address inconsistent `text-transform` inheritance for `button` and `select`. All other form control elements do not inherit `text-transform` values. Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. Correct `select` style inheritance in Firefox 4+ and Opera. */
button, select { text-transform: none; }

/** 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` and `video` controls. 2. Correct inability to style clickable `input` types in iOS. 3. Improve usability and consistency of cursor style between image-type `input` and others. */
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ }

/** Re-set default cursor for disabled elements. */
button[disabled], html input[disabled] { cursor: default; }

/** 1. Address box sizing set to `content-box` in IE 8/9. 2. Remove excess padding in IE 8/9. */
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ }

/** 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome (include `-moz` to future-proof). */
input[type="search"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; }

/** Remove inner padding and search cancel button in Safari 5 and Chrome on OS X. */
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }

/** Remove inner padding and border in Firefox 4+. */
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }

/** 1. Remove default vertical scrollbar in IE 8/9. 2. Improve readability and alignment in all browsers. */
textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ }

/* ========================================================================== Tables ========================================================================== */
/** Remove most spacing between table cells. */
table { border-collapse: collapse; border-spacing: 0; }

meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }

meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }

meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }

*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }

html, body { font-size: 100%; }

body { background: #fff; color: #222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }

a:hover { cursor: pointer; }

img, object, embed { max-width: 100%; height: auto; }

object, embed { height: 100%; }

img { -ms-interpolation-mode: bicubic; }

#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }

.left { float: left !important; }

.right { float: right !important; }

.text-left { text-align: left !important; }

.text-right { text-align: right !important; }

.text-center { text-align: center !important; }

.text-justify { text-align: justify !important; }

.hide { display: none; }

.antialiased, body { -webkit-font-smoothing: antialiased; }

img { display: inline-block; vertical-align: middle; }

textarea { height: auto; min-height: 50px; }

select { width: 100%; }

object, svg { display: inline-block; vertical-align: middle; }

.center { margin-left: auto; margin-right: auto; }

.spread { width: 100%; }

p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }

.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.4; color: #003b6b; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }

/* Typography resets */
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }

/* Default Link Styles */
a { color: #00579e; text-decoration: none; line-height: inherit; }
a:hover, a:focus { color: #333; }
a img { border: none; }

/* Default paragraph styles */
p { font-family: Arial, sans-serif; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }

/* Default header styles */
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Arial, sans-serif; font-weight: normal; font-style: normal; color: #7B2D00; text-rendering: optimizeLegibility; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #ff6b15; line-height: 0; }

h1 { font-size: 2.125em; }

h2 { font-size: 1.6875em; }

h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }

h4 { font-size: 1.125em; }

h5 { font-size: 1.125em; }

h6 { font-size: 1em; }

hr { border: solid #ddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }

/* Helpful Typography Defaults */
em, i { font-style: italic; line-height: inherit; }

strong, b { font-weight: bold; line-height: inherit; }

small { font-size: 60%; line-height: inherit; }

code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: bold; color: #003426; }

/* Lists */
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 0.75em; list-style-position: outside; font-family: Arial, sans-serif; }

ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }

/* Unordered Lists */
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; /* Override nested font-size change */ }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }

/* Ordered Lists */
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }

/* Definition Lists */
dl dt { margin-bottom: 0.3em; font-weight: bold; }
dl dd { margin-bottom: 0.75em; }

/* Abbreviations */
abbr, acronym { text-transform: uppercase; font-size: 90%; color: black; border-bottom: 1px dotted #ddd; cursor: help; }

abbr { text-transform: none; }

/* Blockquotes */
blockquote { margin: 0 0 0.75em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #ddd; }
blockquote cite { display: block; font-size: 0.8125em; color: #e15200; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #e15200; }

blockquote, blockquote p { line-height: 1.6; color: #333; }

/* Microformats */
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #ddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }

.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }

@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
/* Tables */
table { background: #fff; margin-bottom: 1.25em; border: solid 1px #d8d8ce; }
table thead, table tfoot { background: -webkit-linear-gradient(top, #add386, #90b66a); font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #fff; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #6d6e71; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #edf2f2; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.4; }

body { tab-size: 4; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }

a:hover, a:focus { text-decoration: underline; }

.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }

*:not(pre) > code { font-size: inherit; font-style: normal !important; letter-spacing: 0; padding: 3px 2px 1px 2px; background-color: #eee; border: 1px solid #ddd; -webkit-border-radius: 0; border-radius: 0; line-height: inherit; }

pre, pre > code { line-height: 1.6; color: black; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }

.keyseq { color: #333333; }

kbd { font-family: Consolas, "Liberation Mono", Courier, monospace; display: inline-block; color: black; font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }

.keyseq kbd:first-child { margin-left: 0; }

.keyseq kbd:last-child { margin-right: 0; }

.menuseq, .menu { color: black; }

b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }

b.button:before { content: "["; padding: 0 3px 0 2px; }

b.button:after { content: "]"; padding: 0 2px 0 3px; }

#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 1.5em; padding-right: 1.5em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }

#content { margin-top: 1.25em; }

#content:before { content: none; }

#header > h1:first-child { color: #7B2D00; margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #ddd; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #ddd; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #ddd; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: #e15200; display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: #333; }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: #333; }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }

#content > h1:first-child:not([class]) { color: #7B2D00; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }

#toc { border-bottom: 0 solid #ddd; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: Arial, sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }

#toctitle { color: #003b6b; font-size: 1.2em; }

@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background-color: #fff; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #ddd; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #ddd; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }

#footer { max-width: 100%; background-color: none; padding: 1.25em; }

#footer-text { color: black; line-height: 1.44; }

.sect1 { padding-bottom: 0.625em; }

@media only screen and (min-width: 768px) { .sect1 { padding-bottom: 1.25em; } }
.sect1 + .sect1 { border-top: 0 solid #ddd; }

#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #7B2D00; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #622400; }

.audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }

.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; }

table.tableblock > caption.title { white-space: nowrap; overflow: visible; max-width: 0; }

.paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { color: #7B2D00; }

table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }

.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: Arial, sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #ddd; color: #e15200; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }

.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }

.sidebarblock { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: #fff; -webkit-border-radius: 0; border-radius: 0; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: #003b6b; margin-top: 0; }

.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }

.literalblock pre, .listingblock pre:not(.highlight), .listingblock pre[class="highlight"], .listingblock pre[class^="highlight "], .listingblock pre.CodeRay, .listingblock pre.prettyprint { background: #eee; }
.sidebarblock .literalblock pre, .sidebarblock .listingblock pre:not(.highlight), .sidebarblock .listingblock pre[class="highlight"], .sidebarblock .listingblock pre[class^="highlight "], .sidebarblock .listingblock pre.CodeRay, .sidebarblock .listingblock pre.prettyprint { background: #f2f1f1; }

.literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { border: 1px dashed #666; -webkit-border-radius: 0; border-radius: 0; word-wrap: break-word; padding: 1.25em 1.5625em 1.125em 1.5625em; font-size: 0.8125em; }
.literalblock pre.nowrap, .literalblock pre[class].nowrap, .listingblock pre.nowrap, .listingblock pre[class].nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
@media only screen and (min-width: 768px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 0.90625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .literalblock pre[class], .listingblock pre, .listingblock pre[class] { font-size: 1em; } }

.literalblock.output pre { color: #eee; background-color: black; }

.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1.25em 1.5625em 1.125em 1.5625em; -webkit-border-radius: 0; border-radius: 0; }

.listingblock > .content { position: relative; }

.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: #999; }

.listingblock:hover code[data-lang]:before { display: block; }

.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }

.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }

table.pyhltable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }

table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; line-height: 1.6; }

table.pyhltable td.code { padding-left: .75em; padding-right: 0; }

pre.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #ddd; }

pre.pygments .lineno { display: inline-block; margin-right: .25em; }

table.pyhltable .linenodiv { background: none !important; padding-right: 0 !important; }

.quoteblock { margin: 0 1em 0.75em 1.5em; display: table; }
.quoteblock > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock blockquote p { color: #333; font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: #003b6b; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.5em; margin-right: 0.5ex; text-align: right; }
.quoteblock .quoteblock { margin-left: 0; margin-right: 0; padding: 0.5em 0; border-left: 3px solid #e15200; }
.quoteblock .quoteblock blockquote { padding: 0 0 0 0.75em; }
.quoteblock .quoteblock blockquote:before { display: none; }

.verseblock { margin: 0 1em 0.75em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: #333; font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }

.quoteblock .attribution, .verseblock .attribution { font-size: 0.8125em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: #e15200; }

.quoteblock.abstract { margin: 0 0 0.75em 0; display: block; }
.quoteblock.abstract blockquote, .quoteblock.abstract blockquote p { text-align: left; word-spacing: 0; }
.quoteblock.abstract blockquote:before, .quoteblock.abstract blockquote p:first-of-type:before { display: none; }

table.tableblock { max-width: 100%; border-collapse: separate; }
table.tableblock td > .paragraph:last-child p > p:last-child, table.tableblock th > p:last-child, table.tableblock td > p:last-child { margin-bottom: 0; }

table.tableblock, th.tableblock, td.tableblock { border: 0 solid #d8d8ce; }

table.grid-all th.tableblock, table.grid-all td.tableblock { border-width: 0 1px 1px 0; }

table.grid-all tfoot > tr > th.tableblock, table.grid-all tfoot > tr > td.tableblock { border-width: 1px 1px 0 0; }

table.grid-cols th.tableblock, table.grid-cols td.tableblock { border-width: 0 1px 0 0; }

table.grid-all * > tr > .tableblock:last-child, table.grid-cols * > tr > .tableblock:last-child { border-right-width: 0; }

table.grid-rows th.tableblock, table.grid-rows td.tableblock { border-width: 0 0 1px 0; }

table.grid-all tbody > tr:last-child > th.tableblock, table.grid-all tbody > tr:last-child > td.tableblock, table.grid-all thead:last-child > tr > th.tableblock, table.grid-rows tbody > tr:last-child > th.tableblock, table.grid-rows tbody > tr:last-child > td.tableblock, table.grid-rows thead:last-child > tr > th.tableblock { border-bottom-width: 0; }

table.grid-rows tfoot > tr > th.tableblock, table.grid-rows tfoot > tr > td.tableblock { border-width: 1px 0 0 0; }

table.frame-all { border-width: 1px; }

table.frame-sides { border-width: 0 1px; }

table.frame-topbot { border-width: 1px 0; }

th.halign-left, td.halign-left { text-align: left; }

th.halign-right, td.halign-right { text-align: right; }

th.halign-center, td.halign-center { text-align: center; }

th.valign-top, td.valign-top { vertical-align: top; }

th.valign-bottom, td.valign-bottom { vertical-align: bottom; }

th.valign-middle, td.valign-middle { vertical-align: middle; }

table thead th, table tfoot th { font-weight: bold; }

tbody tr th { display: table-cell; line-height: 1.4; background: -webkit-linear-gradient(top, #add386, #90b66a); }

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: #fff; font-weight: bold; }

p.tableblock > code:only-child { background: none; padding: 0; }

p.tableblock { font-size: 1em; }

td > div.verse { white-space: pre; }

ol { margin-left: 1.75em; }

ul li ol { margin-left: 1.5em; }

dl dd { margin-left: 1.125em; }

dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }

ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.375em; }

ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }

ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }

ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1em; font-size: 0.85em; }

ul.checklist li > p:first-child > input[type="checkbox"]:first-child { width: 1em; position: relative; top: 1px; }

ul.inline { margin: 0 auto 0.375em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }

.unstyled dl dt { font-weight: normal; font-style: normal; }

ol.arabic { list-style-type: decimal; }

ol.decimal { list-style-type: decimal-leading-zero; }

ol.loweralpha { list-style-type: lower-alpha; }

ol.upperalpha { list-style-type: upper-alpha; }

ol.lowerroman { list-style-type: lower-roman; }

ol.upperroman { list-style-type: upper-roman; }

ol.lowergreek { list-style-type: lower-greek; }

.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }

td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }

td.hdlist1 { font-weight: bold; padding-bottom: 0.75em; }

.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }

.colist > table tr > td:first-of-type { padding: 0 0.75em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }

.thumb, .th { line-height: 0; display: inline-block; border: solid 4px #fff; -webkit-box-shadow: 0 0 0 1px #ddd; box-shadow: 0 0 0 1px #ddd; }

.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }

.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }

a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }

sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }

#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.05em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }

.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }

div.unbreakable { page-break-inside: avoid; }

.big { font-size: larger; }

.small { font-size: smaller; }

.underline { text-decoration: underline; }

.overline { text-decoration: overline; }

.line-through { text-decoration: line-through; }

.aqua { color: #00bfbf; }

.aqua-background { background-color: #00fafa; }

.black { color: black; }

.black-background { background-color: black; }

.blue { color: #0000bf; }

.blue-background { background-color: #0000fa; }

.fuchsia { color: #bf00bf; }

.fuchsia-background { background-color: #fa00fa; }

.gray { color: #606060; }

.gray-background { background-color: #7d7d7d; }

.green { color: #006000; }

.green-background { background-color: #007d00; }

.lime { color: #00bf00; }

.lime-background { background-color: #00fa00; }

.maroon { color: #600000; }

.maroon-background { background-color: #7d0000; }

.navy { color: #000060; }

.navy-background { background-color: #00007d; }

.olive { color: #606000; }

.olive-background { background-color: #7d7d00; }

.purple { color: #600060; }

.purple-background { background-color: #7d007d; }

.red { color: #bf0000; }

.red-background { background-color: #fa0000; }

.silver { color: #909090; }

.silver-background { background-color: #bcbcbc; }

.teal { color: #006060; }

.teal-background { background-color: #007d7d; }

.white { color: #bfbfbf; }

.white-background { background-color: #fafafa; }

.yellow { color: #bfbf00; }

.yellow-background { background-color: #fafa00; }

span.icon > .fa { cursor: default; }

.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #004177; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }

.conum[data-value] { display: inline-block; color: #fff !important; background-color: black; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }

b.conum * { color: inherit !important; }

.conum:not([data-value]):empty { display: none; }

h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { border-bottom: 1px solid #ddd; }

.sect1 { padding-bottom: 0; }

#toctitle { color: #00406F; font-weight: normal; margin-top: 1.5em; }

.sidebarblock { border-color: #aaa; }

code { -webkit-border-radius: 4px; border-radius: 4px; }

p.tableblock.header { color: #6d6e71; }

.literalblock pre, .listingblock pre { background: #eee; }

</style>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>The Elasticsearch Definitive Guide</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#_life_inside_a_cluster">Life inside a cluster</a>
<ul class="sectlevel1">
<li><a href="#_an_empty_cluster">1. An Empty Cluster</a></li>
<li><a href="#_cluster_health">2. Cluster Health</a></li>
<li><a href="#_add_an_index">3. Add an Index</a></li>
<li><a href="#_add_failover">4. Add Failover</a></li>
</ul>
</li>
<li><a href="#_data_in_data_out">Data In Data Out</a>
<ul class="sectlevel1">
<li><a href="#_what_s_a_document">5. What&#8217;s a document?</a></li>
<li><a href="#_document_metadata">6. Document Metadata</a>
<ul class="sectlevel2">
<li><a href="#__index">6.1. _index</a></li>
<li><a href="#__type">6.2. _type</a></li>
<li><a href="#__id">6.3. _id</a></li>
</ul>
</li>
<li><a href="#_indexing_a_document">7. Indexing a Document</a>
<ul class="sectlevel2">
<li><a href="#_using_our_own_id">7.1. Using Our Own Id</a></li>
<li><a href="#_autogenerating_ids">7.2. Autogenerating IDs</a></li>
<li><a href="#_retrieving_a_document">7.3. Retrieving a Document</a></li>
<li><a href="#_retrieving_part_of_a_document">7.4. Retrieving Part of a Document</a></li>
</ul>
</li>
<li><a href="#_checking_whether_a_document_exists">8. Checking Whether a Document Exists</a></li>
<li><a href="#_updating_a_whole_document">9. Updating a Whole Document</a></li>
<li><a href="#_creating_a_new_document">10. Creating a New Document</a></li>
<li><a href="#_deleting_a_document">11. Deleting a Document</a></li>
<li><a href="#_dealing_with_conflicts">12. Dealing with Conflicts</a></li>
<li><a href="#_optimistic_concurrency_control">13. Optimistic Concurrency Control</a>
<ul class="sectlevel2">
<li><a href="#_示例">13.1. 示例</a></li>
</ul>
</li>
<li><a href="#_using_versions_from_an_external_system">14. Using Versions from an External System</a></li>
<li><a href="#_partial_updates_to_documents">15. Partial Updates to Documents</a>
<ul class="sectlevel2">
<li><a href="#_using_scripts_to_make_partial_updates">15.1. Using Scripts to Make Partial Updates</a></li>
<li><a href="#_updating_a_document_that_may_not_yet_exist">15.2. Updating a Document That May Not Yet Exist</a></li>
<li><a href="#_updates_and_conflicts">15.3. Updates and Conflicts</a></li>
</ul>
</li>
<li><a href="#_retrieving_multiple_documents">16. Retrieving Multiple Documents</a></li>
<li><a href="#_cheaper_in_bulk">17. Cheaper in Bulk</a>
<ul class="sectlevel2">
<li><a href="#_don_t_repeat_yourself">17.1. Don’t Repeat Yourself</a></li>
<li><a href="#_how_big_is_too_big">17.2. How Big Is Too Big?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_分布式文档存储">分布式文档存储</a>
<ul class="sectlevel1">
<li><a href="#_路由文档至分片">18. 路由文档至分片</a></li>
<li><a href="#_主_备分片如何交互">19. 主、备分片如何交互</a></li>
<li><a href="#_创建_删除文档">20. 创建、删除文档</a></li>
<li><a href="#_检索一个文档">21. 检索一个文档</a></li>
<li><a href="#_局部更新一个文档">22. 局部更新一个文档</a></li>
<li><a href="#_多文档模式">23. 多文档模式</a></li>
<li><a href="#_bulk格式解释">24. bulk格式解释</a></li>
</ul>
</li>
<li><a href="#_基本搜索">基本搜索</a>
<ul class="sectlevel1">
<li><a href="#_无请求体的检索">25. 无请求体的检索</a>
<ul class="sectlevel2">
<li><a href="#_hits">25.1. hits</a></li>
<li><a href="#_took">25.2. took</a></li>
<li><a href="#_shards">25.3. shards</a></li>
<li><a href="#_timeout">25.4. timeout</a></li>
</ul>
</li>
<li><a href="#_多索引_多类型">26. 多索引，多类型</a></li>
<li><a href="#_分页">27. 分页</a></li>
<li><a href="#_简单搜索">28. 简单搜索</a>
<ul class="sectlevel2">
<li><a href="#__all字段">28.1. _all字段</a></li>
</ul>
</li>
<li><a href="#_更复杂的查询语句">29. 更复杂的查询语句</a></li>
</ul>
</li>
<li><a href="#_映射与分析">映射与分析</a>
<ul class="sectlevel1">
<li><a href="#_精确值类型与全文类型比较">30. 精确值类型与全文类型比较</a>
<ul class="sectlevel2">
<li><a href="#_倒排索引">30.1. 倒排索引</a></li>
</ul>
</li>
<li><a href="#_分析与分析器">31. 分析与分析器</a>
<ul class="sectlevel2">
<li><a href="#_内置的分析器">31.1. 内置的分析器</a></li>
<li><a href="#_当分析器使用时">31.2. 当分析器使用时</a></li>
<li><a href="#_测试分析器">31.3. 测试分析器</a></li>
<li><a href="#_指定使用的分析器">31.4. 指定使用的分析器</a></li>
</ul>
</li>
<li><a href="#_映射">32. 映射</a>
<ul class="sectlevel2">
<li><a href="#_核心简单字段类型">32.1. 核心简单字段类型</a></li>
<li><a href="#_查看映射">32.2. 查看映射</a></li>
<li><a href="#_自定义字段映射">32.3. 自定义字段映射</a>
<ul class="sectlevel3">
<li><a href="#_index">32.3.1. index</a></li>
</ul>
</li>
<li><a href="#_更新映射">32.4. 更新映射</a></li>
<li><a href="#_测试映射">32.5. 测试映射</a></li>
</ul>
</li>
<li><a href="#_复合类型">33. 复合类型</a>
<ul class="sectlevel2">
<li><a href="#_多值字段">33.1. 多值字段</a></li>
<li><a href="#_空字段">33.2. 空字段</a></li>
<li><a href="#_多级_嵌套_对象">33.3. 多级（嵌套）对象</a></li>
<li><a href="#_嵌套对象的映射">33.4. 嵌套对象的映射</a></li>
<li><a href="#_嵌套对象是怎样被索引的">33.5. 嵌套对象是怎样被索引的</a></li>
<li><a href="#_嵌套对象数组">33.6. 嵌套对象数组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_结构化查询">结构化查询</a>
<ul class="sectlevel1">
<li><a href="#_空搜索">34. 空搜索</a></li>
<li><a href="#_query_dsl">35. Query DSL</a></li>
<li><a href="#_查询_vs_过滤">36. 查询 VS 过滤</a></li>
<li><a href="#_基本查询">37. 基本查询</a>
<ul class="sectlevel2">
<li><a href="#_匹配所有">37.1. 匹配所有</a></li>
<li><a href="#_匹配查询">37.2. 匹配查询</a></li>
<li><a href="#_多字段匹配">37.3. 多字段匹配</a></li>
<li><a href="#_范围匹配">37.4. 范围匹配</a></li>
<li><a href="#_词查询">37.5. 词查询</a></li>
<li><a href="#_多词查询">37.6. 多词查询</a></li>
<li><a href="#_存在与否查询">37.7. 存在与否查询</a></li>
<li><a href="#_常量_固定_分数查询">37.8. 常量（固定）分数查询</a></li>
</ul>
</li>
<li><a href="#_验证查询">38. 验证查询</a></li>
</ul>
</li>
<li><a href="#_排序">排序</a>
<ul class="sectlevel1">
<li><a href="#_默认排序">39. 默认排序</a></li>
<li><a href="#_根据字段进行排序">40. 根据字段进行排序</a></li>
<li><a href="#_多级排序">41. 多级排序</a></li>
<li><a href="#_多值字段排序">42. 多值字段排序</a></li>
<li><a href="#_string_字段排序">43. String 字段排序</a></li>
<li><a href="#_什么是相关度">44. 什么是相关度</a>
<ul class="sectlevel2">
<li><a href="#_理解相关度评分">44.1. 理解相关度评分</a></li>
<li><a href="#_理解为什么某一文档匹配上了">44.2. 理解为什么某一文档匹配上了</a></li>
</ul>
</li>
<li><a href="#_doc_values_介绍">45. Doc Values 介绍</a></li>
</ul>
</li>
<li><a href="#_深入理解分布式搜索过程">深入理解分布式搜索过程</a>
<ul class="sectlevel1">
<li><a href="#_查询数据阶段">46. 查询数据阶段</a></li>
<li><a href="#_获取数据阶段">47. 获取数据阶段</a></li>
<li><a href="#_查询参数">48. 查询参数</a>
<ul class="sectlevel2">
<li><a href="#_preference">48.1. preference</a></li>
<li><a href="#_timeout_2">48.2. timeout</a></li>
<li><a href="#_routing">48.3. routing</a></li>
<li><a href="#_search_type">48.4. search_type</a></li>
</ul>
</li>
<li><a href="#_scroll">49. Scroll</a></li>
</ul>
</li>
<li><a href="#_索引管理">索引管理</a>
<ul class="sectlevel1">
<li><a href="#_创建索引">50. 创建索引</a></li>
<li><a href="#_删除索引">51. 删除索引</a></li>
<li><a href="#_索引设置">52. 索引设置</a></li>
<li><a href="#_配置分析器">53. 配置分析器</a></li>
<li><a href="#_自定义分析器">54. 自定义分析器</a>
<ul class="sectlevel2">
<li><a href="#_创建自定义分析器">54.1. 创建自定义分析器</a></li>
</ul>
</li>
<li><a href="#_类型与映射">55. 类型与映射</a>
<ul class="sectlevel2">
<li><a href="#_lucene如何处理文档">55.1. Lucene如何处理文档</a></li>
<li><a href="#_类型如何实现的">55.2. 类型如何实现的</a></li>
<li><a href="#_避免类型陷阱">55.3. 避免类型陷阱</a></li>
<li><a href="#_类型逃逸">55.4. 类型逃逸</a></li>
</ul>
</li>
<li><a href="#_根对象">56. 根对象</a>
<ul class="sectlevel2">
<li><a href="#_properties">56.1. properties</a></li>
<li><a href="#_元数据_source字段">56.2. 元数据：_source字段</a></li>
<li><a href="#_元数据_all字段">56.3. 元数据： _all字段</a></li>
<li><a href="#_元数据_文档唯一性">56.4. 元数据：文档唯一性</a></li>
</ul>
</li>
<li><a href="#_动态映射">57. 动态映射</a></li>
<li><a href="#_自定义动态映射">58. 自定义动态映射</a>
<ul class="sectlevel2">
<li><a href="#_日期检测">58.1. 日期检测</a></li>
<li><a href="#_动态模板">58.2. 动态模板</a></li>
</ul>
</li>
<li><a href="#_默认映射">59. 默认映射</a></li>
<li><a href="#_重建索引">60. 重建索引</a></li>
<li><a href="#_索引别名">61. 索引别名</a></li>
</ul>
</li>
<li><a href="#_深入理解分片">深入理解分片</a>
<ul class="sectlevel1">
<li><a href="#_使文本可搜索">62. 使文本可搜索</a>
<ul class="sectlevel2">
<li><a href="#_不可变性">62.1. 不可变性</a></li>
</ul>
</li>
<li><a href="#_动态更新索引">63. 动态更新索引</a></li>
<li><a href="#_删除与更新">64. 删除与更新</a></li>
<li><a href="#_近实时搜索">65. 近实时搜索</a>
<ul class="sectlevel2">
<li><a href="#_refresh_api">65.1. refresh API</a></li>
</ul>
</li>
<li><a href="#_使数据持久化">66. 使数据持久化</a>
<ul class="sectlevel2">
<li><a href="#_flush_api">66.1. flush api</a></li>
</ul>
</li>
<li><a href="#_合并段">67. 合并段</a>
<ul class="sectlevel2">
<li><a href="#_optimize_api">67.1. optimize api</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_结构化查询_2">结构化查询</a>
<ul class="sectlevel1">
<li><a href="#_精确值查询">68. 精确值查询</a>
<ul class="sectlevel2">
<li><a href="#_对数字类型的词查询">68.1. 对数字类型的词查询</a></li>
<li><a href="#_对文本的词查询">68.2. 对文本的词查询</a>
<ul class="sectlevel3">
<li><a href="#_内部过滤操作">68.2.1. 内部过滤操作</a></li>
</ul>
</li>
<li><a href="#_组合过滤查询">68.3. 组合过滤查询</a>
<ul class="sectlevel3">
<li><a href="#_bool_过滤查询">68.3.1. bool 过滤查询</a></li>
<li><a href="#_内嵌的boolean查询">68.3.2. 内嵌的Boolean查询</a></li>
</ul>
</li>
<li><a href="#_多值精确查询_in_查询">68.4. 多值精确查询（IN 查询）</a>
<ul class="sectlevel3">
<li><a href="#_包含_但是不是精确的等于">68.4.1. 包含，但是不是精确的等于</a></li>
<li><a href="#_精确相等">68.4.2. 精确相等</a></li>
</ul>
</li>
<li><a href="#_ranges_范围查询">68.5. Ranges（范围查询）</a>
<ul class="sectlevel3">
<li><a href="#_date类型的范围查询">68.5.1. Date类型的范围查询</a></li>
<li><a href="#_字符串上使用range查询">68.5.2. 字符串上使用Range查询</a></li>
</ul>
</li>
<li><a href="#_空值查询">68.6. 空值查询</a>
<ul class="sectlevel3">
<li><a href="#_exist查询">68.6.1. exist查询</a></li>
<li><a href="#_missing查询">68.6.2. missing查询</a></li>
<li><a href="#_exists_missing_on_objects">68.6.3. exists/missing on Objects</a></li>
</ul>
</li>
<li><a href="#_关于缓存">68.7. 关于缓存</a>
<ul class="sectlevel3">
<li><a href="#_独立的查询缓存">68.7.1. 独立的查询缓存</a></li>
<li><a href="#_自动缓存">68.7.2. 自动缓存</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<h1 id="_life_inside_a_cluster" class="sect0"><a class="anchor" href="#_life_inside_a_cluster"></a>Life inside a cluster</h1>
<div class="sect1">
<h2 id="_an_empty_cluster"><a class="anchor" href="#_an_empty_cluster"></a>1. An Empty Cluster</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/elas_0201.png" alt="elas 0201">
</div>
<div class="title">Figure 1. A cluster with one empty node</div>
</div>
<div class="paragraph">
<p>节点是一个运行的ES实例，而集群则由一到多个节点组成（节点需要有相同的cluster.name）。</p>
</div>
<div class="paragraph">
<p>集群中会有一个节点被推选为 <em>master</em> 节点。 <em>master</em> 节点负责 <strong>集群级别</strong> 的管理工作，如 创建、删除索引，添加、移除节点。 <em>master</em> 节点不负责文档级别的修改或搜索，所以只有一个 <em>master</em> 节点并不会成为集群的瓶颈。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>任何节点都可以成为 <em>master</em> 节点</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于 <em>client</em> 而言，我们可以与集群中的任何节点进行通讯（包括主节点）。每一个节点都知道需要搜索的文档在哪个节点上，也都可以把请求转发到对应的节点上。 <em>client</em> 请求的那个节点将 <strong>负责请求的转发以及收集响应的结果数据</strong> 并最终返回给 <em>client</em> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cluster_health"><a class="anchor" href="#_cluster_health"></a>2. Cluster Health</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在ES中许多统计都可以被监控，但是最重要的莫过于 <em>Cluster Health</em> 。 <em>Cluster Health</em> 将以绿、黄、红三种颜色显示集群的健康程度。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_cluster/health</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">响应</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">cluster_name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">hbgay</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">status</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">yellow</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">timed_out</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">number_of_nodes</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">number_of_data_nodes</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">active_primary_shards</span><span class="delimiter">&quot;</span></span>: <span class="integer">10</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">active_shards</span><span class="delimiter">&quot;</span></span>: <span class="integer">10</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">relocating_shards</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">initializing_shards</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">unassigned_shards</span><span class="delimiter">&quot;</span></span>: <span class="integer">10</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">delayed_unassigned_shards</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">number_of_pending_tasks</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">number_of_in_flight_fetch</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">task_max_waiting_in_queue_millis</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">active_shards_percent_as_number</span><span class="delimiter">&quot;</span></span>: <span class="integer">50</span>
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">green</dt>
<dd>
<p>所有的主、备分片都被激活了</p>
</dd>
<dt class="hdlist1">yellow</dt>
<dd>
<p>所有的主分片激活了，但是备份分片未激活</p>
</dd>
<dt class="hdlist1">red</dt>
<dd>
<p>有主分片未激活，或者说主分片丢失了</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_add_an_index"><a class="anchor" href="#_add_an_index"></a>3. Add an Index</h2>
<div class="sectionbody">
<div class="paragraph">
<p>往ES中存储数据时，我们需要一个 <em>index</em> 用于来存储数据。实际上 <em>index</em> 只是一个逻辑上的命名，它实际上是由多个物理上的 <em>shard</em> 组成。</p>
</div>
<div class="paragraph">
<p>一个 <em>shard</em> 是一个低级别的工作单元，它用于存储一个 <em>index</em> 中所有数据的 <strong>一部分</strong> 。 <em>shard</em> 是一单个 <em>Lucene</em> 实例，并且是一个完整的搜索引擎。我们的数据都是存储在 <em>shard</em> 中的，然而我们的程序却不直接跟 <em>shard</em> 交互，而是跟 <em>index</em> 交互。</p>
</div>
<div class="paragraph">
<p><em>shards</em> 正是ES分布式的关键。ES将 <em>shards</em> 分布在各个节点上来实现负载平衡。</p>
</div>
<div class="paragraph">
<p>一个 <em>shard</em> 可以是主分片或备份分片。每一个doc（每一条数据）在 <em>index</em> 中都只属于一个主分片，所以主分片的数量就直接决定了你的 <em>index</em> 能存储的数据的最大量。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>一个主分片理论上是可以存储 <strong>Integer.MAX_VALUE</strong> - 128 条数据的，然而实际上可以存储的数据量取决于你的硬件、数据的大小及复杂程度、索引与搜索的方式，还有你期望的搜索响应时间。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个备份分片则实际上是主分片的一个拷贝。备份分片主要用于提供数据的冗余以避免磁盘挂掉，而且备份分片可以服务那些读的请求（搜索或检索文档）。</p>
</div>
<div class="paragraph">
<p>主分片的数量在索引创建时就指定了且不可以更改，而备份的份数则可以随时更改。默认情况下，建立一个索引时会分5个主分片。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_add_failover"><a class="anchor" href="#_add_failover"></a>4. Add Failover</h2>
<div class="sectionbody">

</div>
</div>
<h1 id="_data_in_data_out" class="sect0"><a class="anchor" href="#_data_in_data_out"></a>Data In Data Out</h1>
<div class="openblock partintro">
<div class="content">
存储在 <em>ES</em> 中的数据，其每一个字段都是默认被索引化的，而且拥有专用的倒排索引。
</div>
</div>
<div class="sect1">
<h2 id="_what_s_a_document"><a class="anchor" href="#_what_s_a_document"></a>5. What&#8217;s a document?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>大多数 <em>entry</em> 或 <em>object</em> 都可以被序列化为 <em>JSON Object</em> 。 <em>key</em> 通常对应一个 <em>field</em> ，而 <em>value</em> 则可以为一个 <em>string</em> 、 <em>number</em> 、 <em>Boolean</em> 、 或其它的对象及数组等。</p>
</div>
<div class="paragraph">
<p>在 <em>ES</em> 中，通常一个 <em>Json Object</em> 对应为一个 <em>document</em> ，但是它们还是有区别的。 <em>document</em> 指拥有一个唯一ID，且是被序列化为 <em>JSON Object</em> 的根对象。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_document_metadata"><a class="anchor" href="#_document_metadata"></a>6. Document Metadata</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一个文档不仅仅由数据组成，它还需要一些元数据。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">_index</dt>
<dd>
<p>document所在的索引</p>
</dd>
<dt class="hdlist1">_type</dt>
<dd>
<p>document的类型（class)</p>
</dd>
<dt class="hdlist1">_id</dt>
<dd>
<p>document的唯一ID</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="__index"><a class="anchor" href="#__index"></a>6.1. _index</h3>
<div class="paragraph">
<p><em>index</em> 类似于关系型数据库中的一个 <em>database</em> ，用于存放索引数据。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>index</em> 只是逻辑上的一个命名空间，用于组织一到多个 <em>shard</em> 。应用程序不直接跟 <em>shard</em> 打交道，而只会跟 <em>index</em> 交互。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>index</em> 的命名，必须小写，不能以下划线开头，不能有分号。</p>
</div>
</div>
<div class="sect2">
<h3 id="__type"><a class="anchor" href="#__type"></a>6.2. _type</h3>
<div class="paragraph">
<p><em>type</em> 类似于 <em>java</em> 中的 <em>class</em> ，或者说类似于数据库中的表。它用于描述有着相同数据结构的一组文档的类型。</p>
</div>
<div class="paragraph">
<p><em>type</em> 的命名，可以小写或大写，但是不能以下划线开头，也不能包含分号。</p>
</div>
</div>
<div class="sect2">
<h3 id="__id"><a class="anchor" href="#__id"></a>6.3. _id</h3>
<div class="paragraph">
<p><em>id</em> 用于在 <em>type</em> 中唯一定位一个文档，类似于数据库中的 <em>rowid</em> 。索引文档时，可以自己指定 <em>id</em> 或者让 <em>ES</em> 自动生成一个全局唯一的 <em>id</em> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_indexing_a_document"><a class="anchor" href="#_indexing_a_document"></a>7. Indexing a Document</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_using_our_own_id"><a class="anchor" href="#_using_our_own_id"></a>7.1. Using Our Own Id</h3>
<div class="listingblock">
<div class="title">指定自定义 <em>id</em> 格式</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /{index}/{type}/{id}
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">field</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>,
  ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_autogenerating_ids"><a class="anchor" href="#_autogenerating_ids"></a>7.2. Autogenerating IDs</h3>
<div class="paragraph">
<p>使用 <em>POST</em> 动作，而且省略 <em>id</em> 即可让 <em>ES</em> 自动生成ID。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /{index}/{type}
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">field</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>,
  ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retrieving_a_document"><a class="anchor" href="#_retrieving_a_document"></a>7.3. Retrieving a Document</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /website/blog/<span class="integer">123</span>?pretty</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_retrieving_part_of_a_document"><a class="anchor" href="#_retrieving_part_of_a_document"></a>7.4. Retrieving Part of a Document</h3>
<div class="paragraph">
<p>如果希望限制返回的列信息，则可以按如下操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /website/blog/<span class="integer">123</span>?_source=title,text</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果不希望显示返回的元数据信息，则可以如下操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /website/blog/<span class="integer">123</span>/_source</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_checking_whether_a_document_exists"><a class="anchor" href="#_checking_whether_a_document_exists"></a>8. Checking Whether a Document Exists</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你并不需要文档内容，只是检查下文档是否存在。可以使用 <em>curl</em> ，只返回 <em>head</em> 即可测试文档是否存在。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">C:<span class="error">\</span>Users<span class="error">\</span>zxb&gt;curl -I http:<span class="comment">//localhost:9200/website/blogs/123</span>
HTTP/<span class="float">1.1</span> <span class="integer">200</span> OK
Content-Type: text/plain; charset=UTF-<span class="integer">8</span>
Content-Length: <span class="integer">0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>不存在时，将返回 <em>404</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">C:<span class="error">\</span>Users<span class="error">\</span>zxb&gt;curl -I http:<span class="comment">//localhost:9200/website/blogs/1234</span>
HTTP/<span class="float">1.1</span> <span class="integer">404</span> Not Found
Content-Type: text/plain; charset=UTF-<span class="integer">8</span>
Content-Length: <span class="integer">0</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_updating_a_whole_document"><a class="anchor" href="#_updating_a_whole_document"></a>9. Updating a Whole Document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 <em>ES</em> 中， <strong>document 是不可改变的</strong> 。 所以如果需要更新一个 <em>document</em> ，我们是将该文档给删除，然后再重建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /website/blog/<span class="integer">123</span> <img src="./images/icons/callouts/1.png" alt="1">
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My first blog entry</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>:  <span class="string"><span class="delimiter">&quot;</span><span class="content">I am starting to get the hang of this...</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>:  <span class="string"><span class="delimiter">&quot;</span><span class="content">2014/01/02</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>使用 <em>PUT</em> 覆盖刚才创建的 <em>document</em></td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span> :   <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span> :    <span class="string"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :      <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span> : <span class="integer">2</span>, <img src="./images/icons/callouts/1.png" alt="1">
  <span class="key"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>:   <span class="predefined-constant">false</span>  <img src="./images/icons/callouts/2.png" alt="2">
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>版本号变为2了</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td><em>created</em> 为 <em>false</em></td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>ES</em> 内部是将旧的文档标记为 <em>deleted</em> 状态，然后添加新的文档。当然， <em>ES</em> 是不会立即删除旧的文档，不过你也不可以访问到该文档。 当你插入更多的数据时， <em>ES</em> 会在后台任务中删除。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_a_new_document"><a class="anchor" href="#_creating_a_new_document"></a>10. Creating a New Document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果只希望在文档不存在时才插入文档，那么就需要用到如下的语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /website/blogs/<span class="integer">123</span>?op_type=create <img src="./images/icons/callouts/1.png" alt="1">
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My first blog entry</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">I am starting to get the hang of this...</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2014/01/02</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>指定 op_type 为 <em>create</em> ，如果文档已经存在，它将会报错</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>或者如下语法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /website/blog/<span class="integer">123</span>/_create
{ ... }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">root_cause</span><span class="delimiter">&quot;</span></span>: [
         {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">document_already_exists_exception</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">reason</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">[blogs][123]: document already exists</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">shard</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>
         }
      ],
      <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">document_already_exists_exception</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">reason</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">[blogs][123]: document already exists</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">shard</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>
   },
   <span class="key"><span class="delimiter">&quot;</span><span class="content">status</span><span class="delimiter">&quot;</span></span>: <span class="integer">409</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deleting_a_document"><a class="anchor" href="#_deleting_a_document"></a>11. Deleting a Document</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">delete语法</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">DELETE /website/blog/<span class="integer">123</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文档存在，那么将返回一个 200</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">found</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">4</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_shards</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">successful</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">failed</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文档不存在，那么将返回一个 404</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">found</span><span class="delimiter">&quot;</span></span>: <span class="value">false</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">5</span>,  <img src="./images/icons/callouts/1.png" alt="1">
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_shards</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">successful</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">failed</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>注意，哪怕没有找到，它的版本号也会增加</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dealing_with_conflicts"><a class="anchor" href="#_dealing_with_conflicts"></a>12. Dealing with Conflicts</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/elas_0301.png" alt="elas 0301">
</div>
<div class="title">Figure 2. 没有并发控制的情况</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Pessimistic concurrency control</dt>
<dd>
<p>悲观锁控制，一般数据库中经常使用。这种方法是假设冲突经常发生，所以数据库中就直接将资源锁住以防发生冲突。一般就是在操作资源前将资源锁住，然后确定只有一个线程能对数据进行操作。</p>
</dd>
<dt class="hdlist1">Optimistic concurrency control</dt>
<dd>
<p>乐观锁控制， <em>ES</em> 中使用。这种方法是假设冲突并不频繁发生，而且它也并不会提前锁住资源。 <em>ES</em> 中使用一个 <em>version number</em> ，每次操作该 <em>version number</em> 都会增加，如果执行修改后的 <em>version number</em> 不等于期望的 <em>ES</em> 中的该行数据的 <em>version number</em> ,则该次修改将被忽略，且返回错误给用户。 用户只需要再执行一次修改操作就可以了。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_optimistic_concurrency_control"><a class="anchor" href="#_optimistic_concurrency_control"></a>13. Optimistic Concurrency Control</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>ES</em> 是分布式的。当 <em>documents</em> 被创建、修改、删除时，这个新版本号的文档会被替换到集群中的其它节点。 <em>ES</em> 也是异步和并发的，也就是说这个新文档是并行地替换到其它节点。 <em>ES</em> 需要保证旧版本的修改永远不会覆盖新版本的文档。</p>
</div>
<div class="paragraph">
<p><em>ES</em> 是通过文档的 <em>version</em> 来确保修改能被正确的应用到文档上。</p>
</div>
<div class="sect2">
<h3 id="_示例"><a class="anchor" href="#_示例"></a>13.1. 示例</h3>
<div class="paragraph">
<p>先创建一个文档</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /website/blogs/<span class="integer">2</span>/_create
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">My second blog entry</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">Just trying this out...</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时版本号为1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_shards</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">successful</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">failed</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>
   },
   <span class="key"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>程序其实一般是先取得文档，此时版本号为1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /website/blogs/<span class="integer">2</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">found</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My second blog entry</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Just trying this out...</span><span class="delimiter">&quot;</span></span>
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后再做修改，且希望修改时文档的版本号为1，此时修改成功了，版本号为2。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /website/blogs/<span class="integer">2</span>?version=<span class="integer">1</span>
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">My second blog entry</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">Starting to get the hang of this...</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_shards</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">successful</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">failed</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>
   },
   <span class="key"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果再执行刚才的 <em>PUT</em> 请求，希望版本号为1，那么就会希望409错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /website/blogs/<span class="integer">2</span>?version=<span class="integer">1</span>
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">My second blog entry</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">Starting to get the hang of this...</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">root_cause</span><span class="delimiter">&quot;</span></span>: [
         {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">version_conflict_engine_exception</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">reason</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">[blogs][2]: version conflict, current [2], provided [1]</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">shard</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>
         }
      ],
      <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">version_conflict_engine_exception</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">reason</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">[blogs][2]: version conflict, current [2], provided [1]</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">shard</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>
   },
   <span class="key"><span class="delimiter">&quot;</span><span class="content">status</span><span class="delimiter">&quot;</span></span>: <span class="integer">409</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_versions_from_an_external_system"><a class="anchor" href="#_using_versions_from_an_external_system"></a>14. Using Versions from an External System</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一个通用的应用场景是其它数据库作为数据的存储，将数据 <em>copy</em> 到 <em>ES</em> 中并使用 <em>ES</em> 负责使数据可以被搜索。这种情况也就是说所有的对数据库的修改都需要即时 <em>copy</em> 到 <em>ES</em> 中，这时就会出现上述说到的并发问题了。</p>
</div>
<div class="paragraph">
<p>此时如果数据库中已经有对应的 <em>verion number</em> ，例如库表中的 <em>timestamp</em> 。此时在 <em>ES</em> 中可以通过设置 version_type=external 来使用外部的 <em>version number</em> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>version number</em> 必须大于0且小于 9.2e+8 。 <em>Java</em> 中的Long型值（正数）</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用外部 <em>version number</em> 时，与 <em>ES</em> 默认的 <em>verison number</em> 稍有不同。外部 <em>version number</em> 是判断文档当前的版本号是否比修改操作指定的版本号小，如果小则可修改，否则出错。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /website/blog/<span class="integer">2</span>?version=<span class="integer">5</span>&amp;version_type=external
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My first external blog entry</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>:  <span class="string"><span class="delimiter">&quot;</span><span class="content">Starting to get the hang of this...</span><span class="delimiter">&quot;</span></span>
}

<span class="error">响</span><span class="error">应</span>
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>:   <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>:      <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">5</span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>:  <span class="predefined-constant">true</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在执行修改操作</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /website/blog/<span class="integer">2</span>?version=<span class="integer">10</span>&amp;version_type=external
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My first external blog entry</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>:  <span class="string"><span class="delimiter">&quot;</span><span class="content">This is a piece of cake...</span><span class="delimiter">&quot;</span></span>
}

<span class="error">响</span><span class="error">应</span><span class="error">，</span><span class="error">此</span><span class="error">时</span><span class="error">版</span><span class="error">本</span><span class="error">号</span><span class="error">变</span><span class="error">为</span><span class="integer">10</span><span class="error">了</span>
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>:   <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>:      <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">10</span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>:  <span class="predefined-constant">false</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果此次再执行这个请求（版本为10），就会报错了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_partial_updates_to_documents"><a class="anchor" href="#_partial_updates_to_documents"></a>15. Partial Updates to Documents</h2>
<div class="sectionbody">
<div class="paragraph">
<p>局部更新文档。更新文档包括 <em>retrieve</em> 、 <em>change</em> 、 <em>reindex</em> 三个步骤。因为 <em>ES</em> 中的文档是不可变的，所以 <em>UPDATE</em> api 也是这三个步骤，只不过它是在 <em>shard</em> 内部完成的，此时就不需要从客户端发多次请求来完成这个操作。</p>
</div>
<div class="paragraph">
<p>示例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/blogs/<span class="integer">2</span>/_update
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">doc</span><span class="delimiter">&quot;</span></span>:{
        <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span>: [<span class="string"><span class="delimiter">&quot;</span><span class="content">testing</span><span class="delimiter">&quot;</span></span>],
        <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>:<span class="integer">0</span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">3</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_shards</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">successful</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">failed</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>修改后，此时文档为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">3</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">found</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My second blog entry</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Starting to get the hang of this...</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span>: [
         <span class="string"><span class="delimiter">&quot;</span><span class="content">testing</span><span class="delimiter">&quot;</span></span>
      ]
   }
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_using_scripts_to_make_partial_updates"><a class="anchor" href="#_using_scripts_to_make_partial_updates"></a>15.1. Using Scripts to Make Partial Updates</h3>
<div class="paragraph">
<p>使用脚本局部更新文档。
在使用 <em>Update Api</em> 时可以使用脚本更新 _source 中的内容，在脚本中使用 `ctx._source`引用。</p>
</div>
<div class="listingblock">
<div class="title">示例，更新views的次数</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/blogs/<span class="integer">2</span>/_update
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">script</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">ctx._source.views+=1</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">示例，更新数组字段中的元素</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/blog/<span class="integer">1</span>/_update
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">script</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">ctx._source.tags+=new_tag</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">params</span><span class="delimiter">&quot;</span></span> : {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">new_tag</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>
   }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">示例，根据元素内容删除文档</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/blog/<span class="integer">1</span>/_update
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">script</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">ctx.op = ctx._source.views == count ? 'delete' : 'none'</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">params</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">count</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_updating_a_document_that_may_not_yet_exist"><a class="anchor" href="#_updating_a_document_that_may_not_yet_exist"></a>15.2. Updating a Document That May Not Yet Exist</h3>
<div class="paragraph">
<p>插入更新，文档不存在则插入，存在的话就更新。</p>
</div>
<div class="listingblock">
<div class="title">示例，插入更新</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/blogs/<span class="integer">3</span>/_update
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">doc</span><span class="delimiter">&quot;</span></span>:{ <img src="./images/icons/callouts/1.png" alt="1">
        <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>:<span class="integer">3</span>
    },
    <span class="key"><span class="delimiter">&quot;</span><span class="content">upsert</span><span class="delimiter">&quot;</span></span>:{ <img src="./images/icons/callouts/2.png" alt="2">
        <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">My third blog entry</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">String to get the hang of this...</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>:<span class="integer">1</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span>:[<span class="string"><span class="delimiter">&quot;</span><span class="content">test</span><span class="delimiter">&quot;</span></span>]
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>文档存在时，则使用 <em>doc</em> 中的内容进行更新</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>如果文档不存在，则使用 <em>upsert</em> 中的内容插入</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/blogs/<span class="integer">3</span>/_update
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">script</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">ctx._source.views+=1</span><span class="delimiter">&quot;</span></span>, <img src="./images/icons/callouts/1.png" alt="1">
   <span class="key"><span class="delimiter">&quot;</span><span class="content">upsert</span><span class="delimiter">&quot;</span></span>: { <img src="./images/icons/callouts/2.png" alt="2">
       <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>文档存在时，使用 <em>script</em> 中的内容进行更新</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>文档不存在时，使用 <em>upsert</em> 中的内容插入</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_updates_and_conflicts"><a class="anchor" href="#_updates_and_conflicts"></a>15.3. Updates and Conflicts</h3>
<div class="paragraph">
<p>Update文档时会执行 <em>retrieve</em> 、 <em>change</em> 、 <em>reindex</em> 操作。而 <em>Update</em> 操作在没有指定 <em>version number</em> 时，是默认会以 <em>retrieve</em> 回来的文档的 <em>version number</em> 作为插入时的 <em>version number</em> 的。所以如果 <em>version number</em> 不对， <em>Update</em> 操作会失败。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>使用 retry_on_conflict 参数可以控制更新失败后的重试次数</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/pageviews/<span class="integer">1</span>/_update?retry_on_conflict=<span class="integer">5</span>
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">script</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">ctx._source.views+=1</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">upsert</span><span class="delimiter">&quot;</span></span>: {
       <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_retrieving_multiple_documents"><a class="anchor" href="#_retrieving_multiple_documents"></a>16. Retrieving Multiple Documents</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当需要 <em>retrieve</em> 多个文档时，可以使用 <em>mget</em> 来减少网络传输，避免发多个 <em>request</em> 请求。</p>
</div>
<div class="paragraph">
<p><em>mget</em> 需要一个 <em>docs</em> 数组，每一个 <em>doc</em> 中的内容都需要 _index 、 _type 、 _id 来指定你需要 retrieve 的元素。</p>
</div>
<div class="listingblock">
<div class="title">同时取多个文档</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_mget
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">docs</span><span class="delimiter">&quot;</span></span>:[
        {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>
        },
        {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>
        }
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">docs</span><span class="delimiter">&quot;</span></span>: [
      {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">5</span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">found</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My second blog entry</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Starting to get the hang of this...</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span>: [
               <span class="string"><span class="delimiter">&quot;</span><span class="content">testing</span><span class="delimiter">&quot;</span></span>
            ]
         }
      },
      {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">found</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My third blog entry</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">String to get the hang of this...</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>: <span class="integer">3</span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span>: [
               <span class="string"><span class="delimiter">&quot;</span><span class="content">test</span><span class="delimiter">&quot;</span></span>
            ]
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果多个请求是同一个 index、type 下，那么可以在请求地址中指定默认的index与type。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /website/blogs/_mget
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">docs</span><span class="delimiter">&quot;</span></span>:[
        {<span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>},{<span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>:<span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>}
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>楼上的情况还可以使用 <em>ids</em> 来取文档</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /website/blogs/_mget
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">ids</span><span class="delimiter">&quot;</span></span> : [ <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span> ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">docs</span><span class="delimiter">&quot;</span></span>: [
      {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_version</span><span class="delimiter">&quot;</span></span>: <span class="integer">5</span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">found</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">My second blog entry</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Starting to get the hang of this...</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">views</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span>: [
               <span class="string"><span class="delimiter">&quot;</span><span class="content">testing</span><span class="delimiter">&quot;</span></span>
            ]
         }
      },
      {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blogs</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">found</span><span class="delimiter">&quot;</span></span>: <span class="value">false</span>  <img src="./images/icons/callouts/1.png" alt="1">
      }
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>注意，这里有一个 <em>found</em> 为 <em>false</em> 的</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>此处使用 <em>mget</em> 时，如果有个别文档找不到时， <em>mget</em> 这个请求的响应 <em>CODE</em> 仍旧是200，因为 <em>mget</em> 确实执行成功了。所以此处如果需要判断文档是否存在时，使用 <em>found</em> 来判断。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cheaper_in_bulk"><a class="anchor" href="#_cheaper_in_bulk"></a>17. Cheaper in Bulk</h2>
<div class="sectionbody">
<div class="paragraph">
<p>同 <em>mget</em> 来同时 <em>get</em> 多个文档类似， <em>bulk</em> 则可以同时执行多个 <em>create</em> 、 <em>index</em> 、 <em>update</em> 、 <em>delete</em> 操作。这个在批量插入数据时非常有用。</p>
</div>
<div class="listingblock">
<div class="title">bulk语法</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key">action</span>: { metadata }}<span class="error">\</span>n
{ request body        }<span class="error">\</span>n
{ <span class="key">action</span>: { metadata }}<span class="error">\</span>n
{ request body        }<span class="error">\</span>n  <img src="./images/icons/callouts/1.png" alt="1"> <img src="./images/icons/callouts/2.png" alt="2">
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>注意，每一行都必须以换行（\n）结尾</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>再一点这些内容中不能包含未转义的换行（\n）,这也就是说JSON内容的格式是不能被格式化的，应该不包含换行的。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>示例</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /_bulk
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">delete</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">create</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">My first blog post</span><span class="delimiter">&quot;</span></span> }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>:  { <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">My second blog post</span><span class="delimiter">&quot;</span></span> }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">update</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">website</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">123</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">_retry_on_conflict</span><span class="delimiter">&quot;</span></span> : <span class="integer">3</span>} }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">doc</span><span class="delimiter">&quot;</span></span> : {<span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">My updated blog post</span><span class="delimiter">&quot;</span></span>} }</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>bulk</em> 中的每一个请求都是分开的，其中的任何一个请求都是独立的。所以 <em>bulk</em> 请求不能实现事务，因为某一个请求失败不会影响到其它请求。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_don_t_repeat_yourself"><a class="anchor" href="#_don_t_repeat_yourself"></a>17.1. Don’t Repeat Yourself</h3>
<div class="paragraph">
<p>如果你使用 <em>bulk</em> 写的数据都是相同的 <em>index</em> 、 <em>type</em> 的话，那么将默认的 <em>index</em> 、 <em>type</em> 写在地址中。如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/_bulk
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">log</span><span class="delimiter">&quot;</span></span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">event</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">User logged in</span><span class="delimiter">&quot;</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>不过仍然可以在各自的请求中覆盖默认的索引与类型设置</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /website/log/_bulk
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: {}}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">event</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">User logged in</span><span class="delimiter">&quot;</span></span> }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Overriding the default type</span><span class="delimiter">&quot;</span></span> }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_big_is_too_big"><a class="anchor" href="#_how_big_is_too_big"></a>17.2. How Big Is Too Big?</h3>
<div class="paragraph">
<p>建议的 <em>bulk size</em> 为5-15M</p>
</div>
</div>
</div>
</div>
<h1 id="_分布式文档存储" class="sect0"><a class="anchor" href="#_分布式文档存储"></a>分布式文档存储</h1>
<div class="sect1">
<h2 id="_路由文档至分片"><a class="anchor" href="#_路由文档至分片"></a>18. 路由文档至分片</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当你索引一个文档， 它被存储在单独一个主分片上。 Elasticsearch是如何知道文档属于哪个分片的呢？当你创建一个新文
档， 它是如何知道是应该存储在分片1还是分片2上的呢？</p>
</div>
<div class="paragraph">
<p>这个过程中不能随机存储文档至分片的，因为存储完后我们还需要检索文档（随机存将导致将来无法检索到文档）。实际上，这是由一个简单的公式（算法）决定的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">shard = hash(routing) % number_of_primary_shards <img src="./images/icons/callouts/1.png" alt="1"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>产生的 <em>shard</em> 分片位置永远在 0到number_of_primary_shards - 1之间</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><em>routing</em> 参数可以为任意的字符串，而它默认是文档的 <strong>_id</strong> 字段（_id可以为生成的和自定义的）。</p>
</div>
<div class="paragraph">
<p>这也正说明了为什么 <em>shard</em> 的数量在索引创建时指定后再不能修改了。
如果主分片的数量可以更改的话，那么文档都将不能找到了。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>所有文档级别的 <em>API</em> 都可以接收一个 <em>routing</em> 参数。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>自定义的 <em>routing</em> 值可以保证所有相关的文档都存储在同一 <em>shard</em> 中。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_主_备分片如何交互"><a class="anchor" href="#_主_备分片如何交互"></a>19. 主、备分片如何交互</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/elas_0401.png" alt="elas 0401">
</div>
<div class="title">Figure 3. 三节点集群</div>
</div>
<div class="paragraph">
<p>我们可以将请求发送给集群中的任一节点，每一个节点都是完全有能力处理请求的。每一个节点都知道文档在集群中的位置，也能将请求转发到指定的节点。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_创建_删除文档"><a class="anchor" href="#_创建_删除文档"></a>20. 创建、删除文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>创建、索引、删除文档都操作都是写操作，所以必须保证在主分片上操作成功之后再复制到其它备份分片上。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_0402.png" alt="elas 0402">
</div>
<div class="title">Figure 4. 创建或删除单个文档</div>
</div>
<div class="paragraph">
<p>这里就是必须保证在主、备分片上都操作（创建、删除、索引文档）成功的步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端发送请求至 <em>Node1</em></p>
</li>
<li>
<p><em>Node1</em> 根据文档的 <em>id</em> 算出了该文档所属的shard为0。然后将请求转发给 <em>Node3</em> （因为上面是0的主分片）</p>
</li>
<li>
<p><em>Node3</em> 在主分片(P0)上执行了请求，如果请求成功了，它将把请求转发给 <em>Node1</em> （R0） 和 <em>Node2</em> 上的 （R0）。 如果所有的备份分片所在的节点都执行成功了， <em>Node3</em> 将报告成功给最初的协调节点 <em>Node1</em> ，再由 <em>Node1</em> 将成功响应给客户端。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当请求成功响应到客户端时，此时文档已经在所有的主、备分片上成功执行了。所以你的修改是安全的。</p>
</div>
<div class="paragraph">
<p>这里也有一些可选的请求参数来影响这个过程。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">replication</dt>
<dd>
<p>可选值、sync和async（默认为sync）。如果设置为async则请求到达上图中的 <em>Node3</em> 上的P0时，如果请求成功则立即返回。而此时则是异步将修改同步到备份分片上，所以客户端收到请求成功的话，也不能确定在备份分片上的修改是否成功了。</p>
</dd>
<dt class="hdlist1">consistency</dt>
<dd>
<p>可选值：one（只要主分片激活即可）、all（所有分片都需要激活才行）、quorm（满足法定人数的分片数被激活才可以）。数据一值性，默认情况下 <em>ES</em> 为了保证同步到备份分片上的请求能正确执行。 <em>ES</em> 要求至少有一个法定人数上以上的分片是激活的，否则此时执行索引或删除文档都将失败。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>法定人数的计算公式如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="reserved">int</span>( (primary + number_of_replicas) / <span class="integer">2</span> ) + <span class="integer">1</span>  <img src="./images/icons/callouts/1.png" alt="1"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>number_of_replicas 指的是在配置文件中指定的index.number_of_replicas的数值，默认是为1的。而非备份分片个数的总量。</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">示例</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="reserved">int</span>( (primary + <span class="integer">3</span> replicas) / <span class="integer">2</span> ) + <span class="integer">1</span> = <span class="integer">3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如，假如有3个备份，而你现在只启了两个节点的话，那么你此时做增加、删除文档操作时会受到默认的法定人数的限制，将无法执行增加、删除操作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，出现法定人数限制时，操作会有默认的1分钟超时时间。 <em>ES</em> 会默认等待1分钟才给出报错，因为有可能其它节点此时正好加入集群中呢。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">timeout</dt>
<dd>
<p>如上面的提示所提到的，在做增加、删除文档等操作时，如果受法定人数限制无法进行操作时，会有默认的1分钟等待时间。这个默认的超时时间可以通过 <em>timeout</em> 参数进行指定，如 timeout=1s、timeout=100ms</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_检索一个文档"><a class="anchor" href="#_检索一个文档"></a>21. 检索一个文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一个文档可以从其所属的主分片检索，也可以从其余的备份分片中检索出来。如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_0403.png" alt="elas 0403">
</div>
<div class="title">Figure 5. 单个文档的检索</div>
</div>
<div class="paragraph">
<p>如下是上图操作中涉及到的步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端发送一个 <em>Get</em> 请求至 <em>Node1</em></p>
</li>
<li>
<p><em>Node1</em> 根据文档的 _id 算出其所属的分片为0，而分片0(主、备)在所有的节点中都存在，此时将请求转发至 Node2 （转发的负载默认是轮循机制）</p>
</li>
<li>
<p><em>Node2</em> 检索出文档，并返回给 <em>Node1</em> 。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_局部更新一个文档"><a class="anchor" href="#_局部更新一个文档"></a>22. 局部更新一个文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Update api</em> 组合了 <em>read</em> 与 <em>write</em> 的操作。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_0404.png" alt="elas 0404">
</div>
<div class="title">Figure 6. 局部更新文档</div>
</div>
<div class="paragraph">
<p>上图操作步骤如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端发送请求至 <em>Node1</em></p>
</li>
<li>
<p><em>Node1</em> 根据请求要修改的文档的 _id 算出其分片为0，此时将请求转发至有主分片0的 Node3</p>
</li>
<li>
<p><em>Node3</em> 先检索出要修改的文档，然后应用要修改的内容在主分片0上。如果该文档已经被其它 <em>process</em> 修改过了，那么将重复指定次数（retry_on_conflict），否则放弃。</p>
</li>
<li>
<p>如果 <em>Node3</em> 成功更新了该文档， <em>Node3</em> 将把更新后的文档并行更新到其它节点上的备份分片。当所有的备份分片都返回成功后， <em>Node3</em> 将返回成功状态给协调节点 <em>Node1</em> ，然后 <em>Node1</em> 再返回成功状态响应返回给客户端。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>Update api</em> 可以接收 <em>routing</em> , <em>replication</em> , <em>consistency</em> , <em>timeout</em> 参数。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_多文档模式"><a class="anchor" href="#_多文档模式"></a>23. 多文档模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>多文档操作： <em>mget</em> 与 <em>bulk</em></p>
</div>
<div class="paragraph">
<p>多文档操作时，将会把多个文档操作的请求拆分为单独的文档操作然后并行分发到各个对应的节点上来处理。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_0405.png" alt="elas 0405">
</div>
<div class="title">Figure 7. 使用 <em>mget</em> 获取多个文档</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_0406.png" alt="elas 0406">
</div>
<div class="title">Figure 8. 使用 <em>bulk</em> 操作多个文档</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bulk格式解释"><a class="anchor" href="#_bulk格式解释"></a>24. bulk格式解释</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为什么 <em>bulk</em> 的格式如此渣，主要出于效率考虑。如果文档格式太 <em>pretty</em> ，那么一是会造成网络流量大，二是造成 <em>ES</em> 解析请求变得复杂。这样一来降低了请求的效率。</p>
</div>
</div>
</div>
<h1 id="_基本搜索" class="sect0"><a class="anchor" href="#_基本搜索"></a>基本搜索</h1>
<div class="openblock partintro">
<div class="content">
<div class="olist arabic">
<div class="title"><em>ES</em> 可以做以下的搜索</div>
<ol class="arabic">
<li>
<p>结构化查询，如根据某一字段 <em>gender</em> 或 <em>age</em> 查询，然后再根据字段 <em>join date</em> 排序。</p>
</li>
<li>
<p>全文查询，找到所有匹配关键字的文档，并按相关度进行排序</p>
</li>
<li>
<p>上述二者结合查询</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了更深入的了解 <em>search</em> ，你需要了解以下几个模块。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Mapping</dt>
<dd>
<p>在每一个字段中数据是如何存储或解释的</p>
</dd>
<dt class="hdlist1">Analysis</dt>
<dd>
<p>全文是如何被处理并可搜索的</p>
</dd>
<dt class="hdlist1">Query DSL</dt>
<dd>
<p><em>Elasticsearch</em> 使用到的强大的查询语言，就像数据库中有 <em>SQL</em> 作为查询语言一样。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>本章只对上述三个模块作简短介绍，更深入的在 <em>Search in depth</em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_无请求体的检索"><a class="anchor" href="#_无请求体的检索"></a>25. 无请求体的检索</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应信息如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span> :       <span class="integer">14</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : [
        {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>:   <span class="string"><span class="delimiter">&quot;</span><span class="content">us</span><span class="delimiter">&quot;</span></span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>:      <span class="string"><span class="delimiter">&quot;</span><span class="content">7</span><span class="delimiter">&quot;</span></span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span>:   <span class="integer">1</span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
             <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-09-17</span><span class="delimiter">&quot;</span></span>,
             <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">John Smith</span><span class="delimiter">&quot;</span></span>,
             <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>:   <span class="string"><span class="delimiter">&quot;</span><span class="content">The Query DSL is really powerful and flexible</span><span class="delimiter">&quot;</span></span>,
             <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span>
          }
       },
        ... <span class="integer">9</span> RESULTS REMOVED ...
      ],
      <span class="key"><span class="delimiter">&quot;</span><span class="content">max_score</span><span class="delimiter">&quot;</span></span> :   <span class="integer">1</span>
   },
   <span class="key"><span class="delimiter">&quot;</span><span class="content">took</span><span class="delimiter">&quot;</span></span> :           <span class="integer">4</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_shards</span><span class="delimiter">&quot;</span></span> : {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">failed</span><span class="delimiter">&quot;</span></span> :      <span class="integer">0</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">successful</span><span class="delimiter">&quot;</span></span> :  <span class="integer">10</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span> :       <span class="integer">10</span>
   },
   <span class="key"><span class="delimiter">&quot;</span><span class="content">timed_out</span><span class="delimiter">&quot;</span></span> :      <span class="predefined-constant">false</span>
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="_hits"><a class="anchor" href="#_hits"></a>25.1. hits</h3>
<div class="paragraph">
<p>上述最重要的就是 <em>hits</em> ，它包含了所有匹配的文档，其下的 <em>hits</em> 数组包含了前10个匹配到的文档。</p>
</div>
<div class="paragraph">
<p>在 <em>hits</em> 数组中的每一个结果都包含 <code>_index</code> , <code>_type</code>, <code>_id</code> 及 <code>_source</code> 。这里 <em>ES</em> 直接把结果数据给返回了，在其它的搜索引擎中，可能先只会返回 <em>document id</em> ，然后再让你根据 <em>document id</em> 去拿数据。</p>
</div>
<div class="paragraph">
<p>每一个结果也有一个 <code>_score</code> ，它表示文档匹配的相关度分数。结果中的数据默认是按 <code>_score</code> 倒序排的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_took"><a class="anchor" href="#_took"></a>25.2. took</h3>
<div class="paragraph">
<p>表示执行这次检索请求的耗时，单位为 <em>ms</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_shards"><a class="anchor" href="#_shards"></a>25.3. shards</h3>
<div class="paragraph">
<p><code>_shards</code> 在告诉我们这次请求在多少个分片（  <code>total</code>  ）上进行了检索。 <code>failed</code> 表示有多少个分片执行检索失败了， <code>successful</code> 表示有多少个分片执行检索成功了。</p>
</div>
<div class="paragraph">
<p>通常我们不希望会出现分片执行失败的情况，然而当我们的主、备分片都丢失时，该分片上的检索将会 <code>failed</code> ，当然这不会影响同一请求在其它分片上的检索。</p>
</div>
</div>
<div class="sect2">
<h3 id="_timeout"><a class="anchor" href="#_timeout"></a>25.4. timeout</h3>
<div class="paragraph">
<p><code>timeout</code> 用于告诉我们请求是否超时了。默认情况下，查询请求是不会超时的（会一直等待下去）。如果对你而言响应时间比完整的结果更重要的话，那么你可以在查询请求后面加上 <em>timeout</em> 参数，如 timeout=10ms 或 timeout=5s</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?timeout=<span class="integer">300</span>ms</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>ES</em> 会在响应超时前，将所有已经收集到的结果返回。</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<img src="./images/icons/caution.png" alt="Caution">
</td>
<td class="content">
<div class="paragraph">
<p><em>timeout</em> 参数并不会中断查询请求，它只是告诉协调节点（你的客户端连接的节点）在超时时间内把已经收集到的结果给返回并且关闭连接。然而未收集到的结果，那些未在超时时间内完成检索的分片上的检索请求还是会继续，哪怕协调节点已经关闭把结果给返回了。</p>
</div>
<div class="paragraph">
<p>当你关心你的系统的响应时间时，你才需要用 <em>timeout</em> ，而不是说你想中止查询请求。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_多索引_多类型"><a class="anchor" href="#_多索引_多类型"></a>26. 多索引，多类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>ES</em> 可以在整个集群中进行搜索，即跨索引、跨类型进行搜索。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>/_search</code></dt>
<dd>
<p>在所有的索引及其下所有的类型中搜索</p>
</dd>
<dt class="hdlist1"><code>/gb/_search</code></dt>
<dd>
<p>在索引 <code>gb</code> 下的所有类型中搜索</p>
</dd>
<dt class="hdlist1"><code>/gb,us/_search</code></dt>
<dd>
<p>在索引 <code>gb</code> 与 <code>us</code> 下的所有类型中搜索</p>
</dd>
<dt class="hdlist1"><code>/g*,u*/_search</code></dt>
<dd>
<p>在以 <code>g</code> 或  <code>u</code> 开头的索引下的所有类型中搜索</p>
</dd>
<dt class="hdlist1"><code>/gb/user/_search</code></dt>
<dd>
<p>在索引 <code>gb</code> 下的 <code>user</code> 类型中搜索</p>
</dd>
<dt class="hdlist1"><code>/gb,us/user,tweet/_search</code></dt>
<dd>
<p>在索引 <code>gb</code> 或 <code>us</code> 下的 <code>user</code> 或 <code>tweet</code> 类型下搜索</p>
</dd>
<dt class="hdlist1"><code>/_all/user,tweet/_search</code></dt>
<dd>
<p>在所有索引下的 <code>user</code> 或 <code>tweet</code> 类型下搜索</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_分页"><a class="anchor" href="#_分页"></a>27. 分页</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">from</dt>
<dd>
<p>默认值为0</p>
</dd>
<dt class="hdlist1">size</dt>
<dd>
<p>每页的大小，默认为10</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?size=<span class="integer">5</span>
GET /_search?size=<span class="integer">5</span>&amp;from=<span class="integer">5</span>
GET /_search?size=<span class="integer">5</span>&amp;from=<span class="integer">10</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>分页检索时，要避免 <em>from</em> 太大，或者 <em>size</em> 太大，因为结果是要在返回前进行排序的。注意检索请求是会跨越多个分片的，每一个分片返回它的排序结果，然后再由协调节点集中对所有结果进行排序并返回指定结果给客户端。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">深入分布式系统分页</div>
<div class="paragraph">
<p>为了理解为什么深度分页是有问题的，让我们假设在一个有5个主分片的索引中搜索。当我们请求结果的第一页（结果1到10）时，每个分片产生自己最顶端10个结果然后返回它们给请求节点(requesting node)，它再排序这所有的50个结果以选出顶端的10个结果。</p>
</div>
<div class="paragraph">
<p><span class="red">现在假设我们请求第1000页——结果10001到10010。工作方式都相同，不同的是每个分片都必须产生顶端的10010个结果。然后请求节点排序这50050个结果并丢弃50040个！</span></p>
</div>
<div class="paragraph">
<p>你可以看到在分布式系统中，排序结果的花费随着分页的深入而成倍增长。这也是为什么网络搜索引擎中任何语句不能返回多于1000个结果的原因。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_简单搜索"><a class="anchor" href="#_简单搜索"></a>28. 简单搜索</h2>
<div class="sectionbody">
<div class="paragraph">
<p>查询字符串很方便在命令行查询时使用。</p>
</div>
<div class="paragraph">
<p><span class="blue">查询字符串搜索对于在命令行下运行点对点(ad hoc)查询特别有用。例如这个语句查询所有类型为tweet并在tweet字段中包含elasticsearch字符的文档：</span></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_all/tweet/_search?q=tweet:elasticsearch</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个语句查找name字段中包含"john"和tweet字段包含"mary"的结果。实际的查询只需要：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">+name:john +tweet:mary</code></pre>
</div>
</div>
<div class="paragraph">
<p>"+"前缀表示语句匹配条件必须被满足。类似的"-"前缀表示条件必须不被满足。所有条件如果没有+或-表示是可选的——匹配越多，相关的文档就越多。</p>
</div>
<div class="paragraph">
<p>且(+)、或( )、非(-)</p>
</div>
<div class="sect2">
<h3 id="__all字段"><a class="anchor" href="#__all字段"></a>28.1. _all字段</h3>
<div class="paragraph">
<p>返回包含"mary"字符的所有文档的简单搜索：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?q=mary</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前一个例子中，我们搜索tweet或name字段中包含某个字符的结果。然而，这个语句返回的结果在三个不同的字段中包含"mary"：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用户的名字是“Mary”</p>
</li>
<li>
<p>“Mary”发的六个推文</p>
</li>
<li>
<p>针对“@mary”的一个推文</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Elasticsearch是如何设法找到三个不同字段的结果的？</p>
</div>
<div class="paragraph">
<p>当你索引一个文档，<span class="red">Elasticsearch把所有字符串字段值连接起来放在一个大字符串中，它被索引为一个特殊的字段_all</span>。例如，当索引这个文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">However did I manage before Elasticsearch?</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-09-14</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary Jones</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span>:  <span class="integer">1</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这好比我们增加了一个叫做_all的额外字段值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>查询字符串在未明确指定搜索哪个字段时，使用 _all 作为默认检索的字段。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_更复杂的查询语句"><a class="anchor" href="#_更复杂的查询语句"></a>29. 更复杂的查询语句</h2>
<div class="sectionbody">
<div class="olist arabic">
<div class="title">搜索语句</div>
<ol class="arabic">
<li>
<p><em>name</em> 字段包含 <em>mary</em> 或 <em>john</em></p>
</li>
<li>
<p><em>date</em> 大于 <em>2014-09-10</em></p>
</li>
<li>
<p><code>_all</code> 字段包含 <em>aggregations</em> 或 <em>geo</em></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">+name:(mary john) +date:&gt;<span class="integer">2014</span>-<span class="integer">09</span>-<span class="integer">10</span> +(aggregations geo)</code></pre>
</div>
</div>
<div class="paragraph">
<p>就像你上面看到的例子，简单(lite)查询字符串搜索惊人的强大。它的查询语法，会在《查询字符串语法》章节阐述。参考文档允许我们简洁明快的表示复杂的查询。这对于命令行下一次性查询或者开发模式下非常有用。</p>
</div>
<div class="paragraph">
<p>然而，你可以看到简洁带来了隐晦和调试困难。而且它很脆弱——查询字符串中一个细小的语法错误，像-、:、/或"错位就会导致返回错误而不是结果。</p>
</div>
<div class="paragraph">
<p>最后，查询字符串搜索允许任意用户在索引中任何一个字段上运行潜在的慢查询语句，可能暴露私有信息甚至使你的集群瘫痪。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>因为这些原因，我们不建议直接暴露查询字符串搜索给用户，除非这些用户对于你的数据和集群可信。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通常，应该使用 <em>Query DSL</em> 来代替查询字符串，它更强大。在了解 <em>Query DSL</em> 之前，还需要了解下数据如何在 <em>ES</em> 中存储的。</p>
</div>
</div>
</div>
<h1 id="_映射与分析" class="sect0"><a class="anchor" href="#_映射与分析"></a>映射与分析</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>我们在处理数据时，有时可能会注意到一些奇怪的现象。为什么我的索引里面有12条数据，并且其中只有一条数据的 <em>date</em> 是 2014-09-15 ，然而执行以下几种查询后的结果却是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /us,gb/_search?q=<span class="integer">2014</span>             <span class="error">#</span> <span class="integer">12</span> results

GET /us,gb/_search?q=<span class="integer">2014</span>-<span class="integer">09</span>-<span class="integer">15</span>       <span class="error">#</span> <span class="integer">12</span> results !

GET /us,gb/_search?q=date:<span class="integer">2014</span>-<span class="integer">09</span>-<span class="integer">15</span>  <span class="error">#</span> <span class="integer">1</span>  result

GET /us,gb/_search?q=date:<span class="integer">2014</span>        <span class="error">#</span> <span class="integer">0</span>  results !</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面可以看到，为什么用 2014-09-15 检索 <code>_all</code> 字段时返回了12条数据，而用 2014 检索 date 字段却没有结果返回？</p>
</div>
<div class="paragraph">
<p>因为存储数据到 <code>_all</code> 与 date 字段时的方式是不同的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><code>_all</code> 为字符串类型，且是所有字段合集，而 date 为日期类型。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>查看一下 <em>tweet</em> 的 <em>mapping</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /gb/_mapping/tweet</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回数据如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">gb</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {
               <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>,
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">strict_date_optional_time||epoch_millis</span><span class="delimiter">&quot;</span></span>
               },
               <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
               },
               <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
               },
               <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">long</span><span class="delimiter">&quot;</span></span>
               }
            }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>_all</code> 虽然在上面的 mapping 中没有体现出来，但是我们知道 <code>_all</code> 是存在的，且类型为 string</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>ES</em> 会根据数据的类型动态创建对应的 <em>Mapping</em> 。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>到目前为止，上述问题最主要的区别在于 <em>ES</em> 中的两种字段类型，精确值类型与全文类型。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_精确值类型与全文类型比较"><a class="anchor" href="#_精确值类型与全文类型比较"></a>30. 精确值类型与全文类型比较</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 <em>ES</em> 中，类型可以被粗分为两种类型：精确值类型、全文值类型</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">精确值类型</dt>
<dd>
<p>精确值类型在索引时是什么样的，查询时匹配也必须是什么样的。</p>
</dd>
<dt class="hdlist1">全文值类型</dt>
<dd>
<p>全文值类型索引时会分词，查询时对查询关键字也会分词。</p>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>全文文本常常被称为 <code>非结构化数据</code> ，其实是一种用词不当的称谓，实际上自然语言是高度结构化的。问题是自然语言的语法规则是如此的复杂，计算机难以正确解析。例如这个句子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">May is fun but June bores me.</code></pre>
</div>
</div>
<div class="paragraph">
<p>到底是说的月份还是人呢？</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>精确值倒是非常容易匹配，因为匹配时要么是匹配上，要么是匹配不上。这种匹配很容易被解释为 <em>SQL</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="keyword">WHERE</span> name    = <span class="string"><span class="delimiter">&quot;</span><span class="content">John Smith</span><span class="delimiter">&quot;</span></span>
  <span class="keyword">AND</span> user_id = <span class="integer">2</span>
  <span class="keyword">AND</span> <span class="predefined-type">date</span>    &gt; <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-09-15</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>而对于全文数据的查询来说，却有些微妙。我们不会去询问`这篇文档是否匹配查询要求？<code>。 但是，我们会询问这篇文档和查询的匹配程度如何？。换句话说，对于查询条件，`这篇文档的相关性有多高？</code></p>
</div>
<div class="paragraph">
<p>我们很少确切的匹配整个全文文本。我们想在全文中查询包含查询文本的部分。不仅如此，我们还期望搜索引擎能理解我们的意图：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个针对"UK"的查询将返回涉及"United Kingdom"的文档</p>
</li>
<li>
<p>一个针对"jump"的查询同时能够匹配"jumped"， "jumps"， "jumping"甚至"leap"</p>
</li>
<li>
<p>"johnny walker"也能匹配"Johnnie Walker"， "johnnie depp"及"Johnny Depp"+</p>
</li>
<li>
<p>"fox news hunting"能返回有关hunting on Fox News的故事，而"fox hunting news"也能返回关于fox hunting的新闻故事。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_倒排索引"><a class="anchor" href="#_倒排索引"></a>30.1. 倒排索引</h3>
<div class="paragraph">
<p><em>ES</em> 使用一个数据结构，称为 <em>inverted index</em> 。倒排索引由在文档中出现的唯一的词列表，以及对于每个词在文档中的位置组成。</p>
</div>
<div class="paragraph">
<p>例如，我们有两个文档，每个文档content字段包含：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The quick brown fox jumped over the lazy dog</p>
</li>
<li>
<p>Quick brown foxes leap over lazy dogs in summer</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>为了创建倒排索引，首先需要将 <em>content</em> 字段拆分为单独的词，然后将所有的词放入列表并排序。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Term</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Doc_1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Doc_2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Quick</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">The</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">brown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dog</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dogs</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fox</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">foxes</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">in</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jumped</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lazy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">leap</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">over</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">quick</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">summer</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">the</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>现在，如何需要搜索 <code>quick brown</code> ,我们只需要找到出现了该词的文档。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Term</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Doc_1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Doc_2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">brown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">quick</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Total</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这两个文档都匹配上了，然而第一个匹配度更高一些。如果我们只简单地根据匹配的词数量来决定相关度，那么明显第一个比第二个的匹配度更高。</p>
</div>
<div class="olist arabic">
<div class="title">但是现在的这个倒排索引存在以下几个问题：</div>
<ol class="arabic">
<li>
<p>"Quick"和"quick"被认为是不同的单词，但是用户可能认为它们是相同的。</p>
</li>
<li>
<p>"fox"和"foxes"很相似，就像"dog"和"dogs"——它们都是同根词。</p>
</li>
<li>
<p>"jumped"和"leap"不是同根词，但意思相似——它们是同义词。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果我们将词为统一为标准格式，这样就可以找到不是确切匹配查询，但是足以相似从而可以关联的文档。例如：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>"Quick"可以转为小写成为"quick"。</p>
</li>
<li>
<p>"foxes"可以被转为根形式"fox"。同理"dogs"可以被转为"dog"。</p>
</li>
<li>
<p>"jumped"和"leap"同义就可以只索引为单个词"jump"</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此时倒排索引就像下面这样</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Term</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Doc_1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Doc_2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">brown</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dog</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fox</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">in</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jump</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lazy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">over</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">quick</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">summer</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">the</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果此时我们以 <em>Quick</em> 搜索还是会失败，因为 <em>Quick</em> 确实不在词表中。这个时候就需要对搜索的词处理成标准格式。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<img src="./images/icons/important.png" alt="Important">
</td>
<td class="content">
<div class="paragraph">
<p>这很重要。你只可以找到确实存在于索引中的词，所以索引文本和查询字符串都要标准化为相同的形式。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这种分词和标准化的过程我们称之为 <em>analysis</em> ，即分析。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_分析与分析器"><a class="anchor" href="#_分析与分析器"></a>31. 分析与分析器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>分析过程由以下几个步骤组成：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将文本拆分为词，并用于倒排索引</p>
</li>
<li>
<p>然后将词处理成标准格式，以提高其搜索性</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>上面说的这个工作由分析器来完成。分析器实际上由下面的三块功能组成：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">字符过滤器</dt>
<dd>
<p>首先字符串经过字符过滤器(character filter)，它们的工作是在标记化前处理字符串。字符过滤器能够去除HTML标记，或者转换"&amp;"为"and"。</p>
</dd>
<dt class="hdlist1">分词器</dt>
<dd>
<p>下一步，分词器(tokenizer)被标记化成独立的词。一个简单的分词器(tokenizer)可以根据空格或逗号将单词分开</p>
</dd>
<dt class="hdlist1">词过滤</dt>
<dd>
<p>最后，每个词都通过所有标记过滤(token filters)，它可以修改词（例如将"Quick"转为小写），去掉词（例如停用词像"a"、"and"、"the"等等），或者增加词（例如同义词像"jump"和"leap"）</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_内置的分析器"><a class="anchor" href="#_内置的分析器"></a>31.1. 内置的分析器</h3>
<div class="paragraph">
<p><em>ElasticSearch</em> 预置了一些分析器，你可以直接使用。下面列出几个比较重要的分析器，演示这个字符串分词后的差异：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>"Set the shape to semi-transparent by calling set_trans(5)"</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">标准分析器</dt>
<dd>
<p>标准分析器是Elasticsearch默认使用的分析器。对于文本分析，它对于任何语言都是最佳选择（译者注：就是没啥特殊需求，对于任何一个国家的语言，这个分析器就够用了）。它根据Unicode Consortium的定义的单词边界(word boundaries)来切分文本，然后去掉大部分标点符号。最后，把所有词转为小写。产生的结果为：</p>
<div class="listingblock">
<div class="content">
<pre>set, the, shape, to, semi, transparent, by, calling, set_trans, 5</pre>
</div>
</div>
</dd>
<dt class="hdlist1">简单分析器</dt>
<dd>
<p>简单分析器将非单个字母的文本切分，然后把每个词转为小写。产生的结果为：</p>
<div class="listingblock">
<div class="content">
<pre>set, the, shape, to, semi, transparent, by, calling, set, trans</pre>
</div>
</div>
</dd>
<dt class="hdlist1">空格分析器</dt>
<dd>
<p>空格分析器依据空格切分文本。它不转换小写。产生结果为：</p>
<div class="listingblock">
<div class="content">
<pre>Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</pre>
</div>
</div>
</dd>
<dt class="hdlist1">语言分析器</dt>
<dd>
<p>特定语言分析器适用于很多语言。它们能够考虑到特定语言的特性。例如，english分析器自带一套英语停用词库——像and或the这些与语义无关的通用词。这些词被移除后，因为语法规则的存在，英语单词的主体含义依旧能被理解（译者注：stem English words这句不知道该如何翻译，查了字典，我理解的大概意思应该是将英语语句比作一株植物，去掉无用的枝叶，主干依旧存在，停用词好比枝叶，存在与否并不影响对这句话的理解。）。</p>
<div class="paragraph">
<p>english分析器将会产生以下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>set, shape, semi, transpar, call, set_tran, 5</pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_当分析器使用时"><a class="anchor" href="#_当分析器使用时"></a>31.2. 当分析器使用时</h3>
<div class="paragraph">
<p>当我们索引(index)一个文档，全文字段会被分析为单独的词来创建倒排索引。不过，当我们在全文字段搜索(search)时，我们要让查询字符串经过同样的分析流程处理，以确保这些词在索引中存在。</p>
</div>
<div class="paragraph">
<p>全文查询我们将在稍后讨论，理解每个字段是如何定义的，这样才可以让它们做正确的事：
. 当你查询全文(full text)字段，查询将使用相同的分析器来分析查询字符串，以产生正确的词列表。
. 当你查询一个确切值(exact value)字段，查询将不分析查询字符串，但是你可以自己指定。</p>
</div>
<div class="paragraph">
<p>现在你可以明白为什么《映射和分析》的开头会产生那种结果:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>date字段包含一个确切值：单独的一个词"2014-09-15"。</p>
</li>
<li>
<p>_all字段是一个全文字段，所以分析过程将日期转为三个词："2014"、"09"和"15"。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当我们在_all字段查询2014，它一个匹配到12条推文，因为这些推文都包含词2014：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?q=<span class="integer">2014</span>              <span class="error">#</span> <span class="integer">12</span> results</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们在_all字段中查询2014-09-15，首先分析查询字符串，产生匹配任一词2014、09或15的查询语句，它依旧匹配12个推文，因为它们都包含词2014。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?q=<span class="integer">2014</span>-<span class="integer">09</span>-<span class="integer">15</span>        <span class="error">#</span> <span class="integer">12</span> results !</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们在date字段中查询2014-09-15，它查询一个确切的日期，然后只找到一条推文：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?q=date:<span class="integer">2014</span>-<span class="integer">09</span>-<span class="integer">15</span>   <span class="error">#</span> <span class="integer">1</span>  result</code></pre>
</div>
</div>
<div class="paragraph">
<p>当我们在date字段中查询2014，没有找到文档，因为没有文档包含那个确切的日期：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?q=date:<span class="integer">2014</span>         <span class="error">#</span> <span class="integer">0</span>  results !</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_测试分析器"><a class="anchor" href="#_测试分析器"></a>31.3. 测试分析器</h3>
<div class="paragraph">
<p>当你新接触 <em>ES</em> 时，通常比较难理解文本是如何分词并索引的。为了更好地理解分析器，可以使用 <em>analyze api</em> 来查看文本是否被分词的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_analyze
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">analyzer</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">standard</span><span class="delimiter">&quot;</span></span>,  <img src="./images/icons/callouts/1.png" alt="1">
  <span class="key"><span class="delimiter">&quot;</span><span class="content">text</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Text to analyze</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/2.png" alt="2">
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>指定选用的分析器</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>指定要分析的文本</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>token是一个实际被存储在索引中的词。position指明词在原文本中是第几个出现的。start_offset和end_offset表示词在原文本中占据的位置</p>
</div>
</div>
<div class="sect2">
<h3 id="_指定使用的分析器"><a class="anchor" href="#_指定使用的分析器"></a>31.4. 指定使用的分析器</h3>
<div class="paragraph">
<p>当Elasticsearch在你的文档中探测到一个新的字符串字段，它将自动设置它为全文string字段并用standard分析器分析。</p>
</div>
<div class="paragraph">
<p>你不可能总是想要这样做。也许你想使用一个更适合这个数据的语言分析器。或者，你只想把字符串字段当作一个普通的字段——不做任何分析，只存储确切值，就像字符串类型的用户ID或者内部状态字段或者标签。</p>
</div>
<div class="paragraph">
<p>为了达到这种效果，我们必须通过映射(mapping)人工设置这些字段。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_映射"><a class="anchor" href="#_映射"></a>32. 映射</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为了能够把日期字段处理成日期，把数字字段处理成数字，把字符串字段处理成全文本（Full-text）或精确的字符串值，Elasticsearch需要知道每个字段里面都包含了什么类型。这些类型和字段的信息存储（包含）在映射（mapping）中。</p>
</div>
<div class="paragraph">
<p>正如《Data In, Data Out》一节所说，索引中每个文档都有一个类型(type)。 每个类型拥有自己的映射(mapping)或者模式定义(schema definition)。一个映射定义了字段类型，每个字段的数据类型，以及字段被Elasticsearch处理的方式。映射还用于设置关联到类型上的元数据。</p>
</div>
<div class="sect2">
<h3 id="_核心简单字段类型"><a class="anchor" href="#_核心简单字段类型"></a>32.1. 核心简单字段类型</h3>
<div class="paragraph">
<p>Elasticsearch支持以下简单字段类型：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">类型</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示的数据类型</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whole number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">byte, short, integer, long</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Floating point</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">float, double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当你索引一个包含新字段的文档——一个之前没有的字段——Elasticsearch将使用动态映射猜测字段类型，这类型来自于JSON的基本数据类型，使用以下规则：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Field type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Boolean: true or false</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"boolean"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whole number: 123</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"long"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Floating point: 123.45</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"double"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String, valid date: "2014-09-15"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"date"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String: "foo bar"</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">"string"</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>这意味着，如果你索引一个带引号的数字——"123"，它将被映射为"string"类型，而不是"long"类型。</p>
</div>
<div class="paragraph">
<p>然而，如果字段已经被映射为"long"类型，你再存储"123"时，Elasticsearch将尝试转换字符串为long，并在转换失败时会抛出异常。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_查看映射"><a class="anchor" href="#_查看映射"></a>32.2. 查看映射</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /gb/_mapping/tweet</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">gb</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {
               <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>,
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">strict_date_optional_time||epoch_millis</span><span class="delimiter">&quot;</span></span>
               },
               <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
               },
               <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
               },
               <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">long</span><span class="delimiter">&quot;</span></span>
               }
            }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>当映射错误时，如将 <em>age</em> 字段用 <em>string</em> 类型而非 <em>integer</em> 类型表示时，这可能会导致你的查询结果令人疑惑。</p>
</div>
<div class="paragraph">
<p>不要假设你的类型映射是正确的，你需要动手检查它。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_自定义字段映射"><a class="anchor" href="#_自定义字段映射"></a>32.3. 自定义字段映射</h3>
<div class="paragraph">
<p>虽然大多数情况下基本数据类型已经能够满足，但你也会经常需要自定义一些特殊类型（fields），特别是字符串字段类型。</p>
</div>
<div class="paragraph">
<p>自定义类型可以使你完成一下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>区分全文（full text）字符串字段和准确字符串字段（译者注：就是分词与不分词，全文的一般要分词，准确的就不需要分词，比如『中国』这个词。全文会分成『中』和『国』，但作为一个国家标识的时候我们是不需要分词的，所以它就应该是一个准确的字符串字段）。</p>
</li>
<li>
<p>使用特定语言的分析器（译者注：例如中文、英文、阿拉伯语，不同文字的断字、断词方式的差异）</p>
</li>
<li>
<p>优化部分匹配字段</p>
</li>
<li>
<p>指定自定义日期格式（译者注：这个比较好理解,例如英文的 <code>Feb,12,2016</code> 和 中文的 <code>2016年2月12日</code>）</p>
</li>
<li>
<p>以及更多</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>映射中最重要的字段参数是`type`。除了`string`类型的字段，你可能很少需要映射其他的`type`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">{

    <span class="key"><span class="delimiter">&quot;</span><span class="content">number_of_clicks</span><span class="delimiter">&quot;</span></span>: {

        <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">integer</span><span class="delimiter">&quot;</span></span>

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>`string`类型的字段，默认的，考虑到包含全文本，它们的值在索引前要经过分析器分析，并且在全文搜索此字段前要把查询语句做分析处理。</p>
</div>
<div class="paragraph">
<p>对于`string`字段，两个最重要的映射参数是`index`和`analyer`。</p>
</div>
<div class="sect3">
<h4 id="_index"><a class="anchor" href="#_index"></a>32.3.1. index</h4>
<div class="paragraph">
<p>`index`参数控制字符串以何种方式被索引。它包含以下三个值当中的一个：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">analyzed</dt>
<dd>
<p>首先分析这个字符串，然后索引。换言之，以全文形式索引此字段。（分词）</p>
</dd>
<dt class="hdlist1">not_analyzed</dt>
<dd>
<p>索引这个字段，使之可以被搜索，但是索引内容和指定值一样。不分析此字段。（不分词）</p>
</dd>
<dt class="hdlist1">no</dt>
<dd>
<p>不索引此字段，这个字段不能被搜索到。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><em>string</em> 类型默认的 <em>index</em> 值为 <code>analyzed</code>，如果我们需要某一 <em>string</em> 类型作为精确值查询，需要设置其 <em>index</em> 值为 <code>not_analyzed</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">tag</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">not_analyzed</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>其他简单类型（<code>long</code>、<code>double</code>、<code>date`等等）也接受`index`参数，但相应的值只能是`no`和`not_analyzed</code>，它们的值不能被分析。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_analyzer"><a class="anchor" href="#_analyzer"></a>analyzer</h5>
<div class="paragraph">
<p>对于`analyzed`类型的字符串字段，使用`analyzer`参数来指定哪一种分析器将在搜索和索引的时候使用。默认的，Elasticsearch使用`standard`分析器，但是你可以通过指定一个内建的分析器来更改它，例如`whitespace`、<code>simple`或`english</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">{

    <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: {

        <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,

        <span class="key"><span class="delimiter">&quot;</span><span class="content">analyzer</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">english</span><span class="delimiter">&quot;</span></span>

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_更新映射"><a class="anchor" href="#_更新映射"></a>32.4. 更新映射</h3>
<div class="paragraph">
<p>你可以在第一次创建索引的时候指定映射的类型。此外，你也可以晚些时候为新类型添加映射（或者为已有的类型更新映射）。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<img src="./images/icons/important.png" alt="Important">
</td>
<td class="content">
<div class="paragraph">
<p>你可以向已有映射中 <strong>增加</strong> 字段，但你不能 <strong>修改</strong> 它。如果一个字段在映射中已经存在，这可能意味着那个字段的数据已经被索引。如果你改变了字段映射，那已经被索引的数据将错误并且不能被正确的搜索到。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们可以更新一个映射来增加一个新字段，但是不能把已有字段的类型那个从`analyzed`改到`not_analyzed`。</p>
</div>
<div class="paragraph">
<p>为了演示两个指定的映射方法，让我们首先删除索引`gb`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sh">DELETE /gb</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后创建一个新索引，指定`tweet`字段的分析器为`english`：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">PUT /gb <img src="./images/icons/callouts/1.png" alt="1">

{

  <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {

    <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span> : {

      <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span> : {

        <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span> : {

          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :    <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,

          <span class="key"><span class="delimiter">&quot;</span><span class="content">analyzer</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">english</span><span class="delimiter">&quot;</span></span>

        },

        <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span> : {

          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :   <span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>

        },

        <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> : {

          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :   <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>

        },

        <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span> : {

          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :   <span class="string"><span class="delimiter">&quot;</span><span class="content">long</span><span class="delimiter">&quot;</span></span>

        }

      }

    }

  }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>这将创建包含`mappings`的索引，映射在请求体中指定。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>再后来，我们决定在`tweet`的映射中增加一个新的`not_analyzed`类型的文本字段，叫做`tag`，使用`_mapping`后缀:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">PUT /gb/_mapping/tweet

{

  <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span> : {

    <span class="key"><span class="delimiter">&quot;</span><span class="content">tag</span><span class="delimiter">&quot;</span></span> : {

      <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :    <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,

      <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">not_analyzed</span><span class="delimiter">&quot;</span></span>

    }

  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意到我们不再需要列出所有的已经存在的字段，因为我们没法修改他们。我们的新字段已经被合并至存在的那个映射中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_测试映射"><a class="anchor" href="#_测试映射"></a>32.5. 测试映射</h3>
<div class="paragraph">
<p>你可以通过名字使用`analyze` API测试字符串字段的映射。对比这两个请求的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">GET /gb/_analyze?field=tweet&amp;text=Black-cats <img src="./images/icons/callouts/1.png" alt="1">

GET /gb/_analyze?field=tag&amp;text=Black-cats</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>我们想要分析的文本被放在请求体中。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>tweet`字段产生两个词，</code>"black"<code>和</code>"cat"<code>,`tag`字段产生单独的一个词</code>"Black-cats"`。换言之，我们的映射工作正常。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_复合类型"><a class="anchor" href="#_复合类型"></a>33. 复合类型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了之前提到的简单的标量类型，JSON还有`null`值，数组和对象，所有这些Elasticsearch都支持：</p>
</div>
<div class="sect2">
<h3 id="_多值字段"><a class="anchor" href="#_多值字段"></a>33.1. 多值字段</h3>
<div class="paragraph">
<p>我们想让`tag`字段包含多个字段，这非常有可能发生。我们可以索引一个标签数组来代替单一字符串：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tag</span><span class="delimiter">&quot;</span></span>: [ <span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">nosql</span><span class="delimiter">&quot;</span></span> ]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于数组不需要特殊的映射。任何一个字段可以包含零个、一个或多个值，同样对于全文字段将被分析并产生多个词。</p>
</div>
<div class="paragraph">
<p>言外之意，这意味着<strong>数组中所有值必须为同一类型</strong>。你不能把日期和字符窜混合。如果你创建一个新字段，这个字段索引了一个数组，Elasticsearch将使用第一个值的类型来确定这个新字段的类型。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>当你从Elasticsearch中取回一个文档，任何一个数组的顺序和你索引它们的顺序一致。你取回的`_source`字段的顺序同样与索引它们的顺序相同。</p>
</div>
<div class="paragraph">
<p>然而，数组是做为多值字段被<strong>索引</strong>的，它们没有顺序。在搜索阶段你不能指定“第一个值”或者“最后一个值”。倒不如把数组当作一个<strong>值集合(bag of values)</strong></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_空字段"><a class="anchor" href="#_空字段"></a>33.2. 空字段</h3>
<div class="paragraph">
<p>当然数组可以是空的。这等价于有零个值。事实上，Lucene没法存放`null`值，所以一个`null`值的字段被认为是空字段。</p>
</div>
<div class="paragraph">
<p>这四个字段将被识别为空字段而 <strong>不被索引</strong> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript"><span class="string"><span class="delimiter">&quot;</span><span class="content">empty_string</span><span class="delimiter">&quot;</span></span>:             <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>,

<span class="key"><span class="delimiter">&quot;</span><span class="content">null_value</span><span class="delimiter">&quot;</span></span>:               <span class="predefined-constant">null</span>,

<span class="key"><span class="delimiter">&quot;</span><span class="content">empty_array</span><span class="delimiter">&quot;</span></span>:              [],

<span class="key"><span class="delimiter">&quot;</span><span class="content">array_with_null_value</span><span class="delimiter">&quot;</span></span>:    [ <span class="predefined-constant">null</span> ]</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多级_嵌套_对象"><a class="anchor" href="#_多级_嵌套_对象"></a>33.3. 多级（嵌套）对象</h3>
<div class="paragraph">
<p>我们需要讨论的最后一个自然JSON数据类型是<strong>对象(object)</strong>——在其它语言中叫做hash、hashmap、dictionary 或者 associative array.</p>
</div>
<div class="paragraph">
<p><strong>内部对象(inner objects)</strong>经常用于在另一个对象中嵌入一个实体或对象。例如，做为在`tweet`文档中`user_name`和`user_id`的替代，我们可以这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">{

    <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>:            <span class="string"><span class="delimiter">&quot;</span><span class="content">Elasticsearch is very flexible</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>: {

        <span class="key"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>:           <span class="string"><span class="delimiter">&quot;</span><span class="content">@johnsmith</span><span class="delimiter">&quot;</span></span>,

        <span class="key"><span class="delimiter">&quot;</span><span class="content">gender</span><span class="delimiter">&quot;</span></span>:       <span class="string"><span class="delimiter">&quot;</span><span class="content">male</span><span class="delimiter">&quot;</span></span>,

        <span class="key"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>:          <span class="integer">26</span>,

        <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: {

            <span class="key"><span class="delimiter">&quot;</span><span class="content">full</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">John Smith</span><span class="delimiter">&quot;</span></span>,

            <span class="key"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>,

            <span class="key"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">Smith</span><span class="delimiter">&quot;</span></span>

        }

    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_嵌套对象的映射"><a class="anchor" href="#_嵌套对象的映射"></a>33.4. 嵌套对象的映射</h3>
<div class="paragraph">
<p>Elasticsearch 会动态的检测新对象的字段，并且映射它们为 <code>object</code> 类型，将每个字段加到 <code>properties</code> 字段下</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{

  <span class="key"><span class="delimiter">&quot;</span><span class="content">gb</span><span class="delimiter">&quot;</span></span>: {

    <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: { <img src="./images/icons/callouts/1.png" alt="1">

      <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {

        <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>:            { <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span> },

        <span class="key"><span class="delimiter">&quot;</span><span class="content">user</span><span class="delimiter">&quot;</span></span>: { <img src="./images/icons/callouts/2.png" alt="2">

          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:             <span class="string"><span class="delimiter">&quot;</span><span class="content">object</span><span class="delimiter">&quot;</span></span>,

          <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {

            <span class="key"><span class="delimiter">&quot;</span><span class="content">id</span><span class="delimiter">&quot;</span></span>:           { <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span> },

            <span class="key"><span class="delimiter">&quot;</span><span class="content">gender</span><span class="delimiter">&quot;</span></span>:       { <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span> },

            <span class="key"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>:          { <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">long</span><span class="delimiter">&quot;</span></span>   },

            <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>:   { <img src="./images/icons/callouts/3.png" alt="3">

              <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:         <span class="string"><span class="delimiter">&quot;</span><span class="content">object</span><span class="delimiter">&quot;</span></span>,

              <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {

                <span class="key"><span class="delimiter">&quot;</span><span class="content">full</span><span class="delimiter">&quot;</span></span>:     { <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span> },

                <span class="key"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>:    { <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span> },

                <span class="key"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span>:     { <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span> }

              }

            }

          }

        }

      }

    }

  }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>根对象.</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>内部对象</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>内部对象.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对`user`和`name`字段的映射与`tweet`类型自己很相似。事实上，<code>type`映射只是`object`映射的一种特殊类型，我们将 `object</code> 称为_根对象_。它与其他对象一模一样，除非它有一些特殊的顶层字段，比如 <code>_source</code>, <code>_all</code> 等等。</p>
</div>
</div>
<div class="sect2">
<h3 id="_嵌套对象是怎样被索引的"><a class="anchor" href="#_嵌套对象是怎样被索引的"></a>33.5. 嵌套对象是怎样被索引的</h3>
<div class="paragraph">
<p>Lucene 并不了解内部对象。 一个 Lucene 文件包含一个 <strong>键-值对应的扁平表单</strong> 。 为了让 Elasticsearch 可以有效的索引内部对象，将文件转换为以下格式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="javascript">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>:            [elasticsearch, flexible, very],
    <span class="key"><span class="delimiter">&quot;</span><span class="content">user.id</span><span class="delimiter">&quot;</span></span>:          [<span class="error">@</span>johnsmith],
    <span class="key"><span class="delimiter">&quot;</span><span class="content">user.gender</span><span class="delimiter">&quot;</span></span>:      [male],
    <span class="key"><span class="delimiter">&quot;</span><span class="content">user.age</span><span class="delimiter">&quot;</span></span>:         [<span class="integer">26</span>],
    <span class="key"><span class="delimiter">&quot;</span><span class="content">user.name.full</span><span class="delimiter">&quot;</span></span>:   [john, smith],
    <span class="key"><span class="delimiter">&quot;</span><span class="content">user.name.first</span><span class="delimiter">&quot;</span></span>:  [john],
    <span class="key"><span class="delimiter">&quot;</span><span class="content">user.name.last</span><span class="delimiter">&quot;</span></span>:   [smith]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>_内部栏位_可被归类至name，例如`"first"<code>。 为了区别两个拥有相同名字的栏位，我们可以使用完整_路径_，例如</code>"user.name.first"` 或甚至`类型`名称加上路径：<code>"tweet.user.name.first"</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>注意： 在以上扁平化文件中，并没有栏位叫作`user`也没有栏位叫作`user.name`。 Lucene 只索引阶层或简单的值，而不会索引复杂的资料结构。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_嵌套对象数组"><a class="anchor" href="#_嵌套对象数组"></a>33.6. 嵌套对象数组</h3>
<div class="paragraph">
<p>最后，一个包含内部对象的数组如何索引。 我们有个数组如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">followers</span><span class="delimiter">&quot;</span></span>: [
        { <span class="key"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>: <span class="integer">35</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Mary White</span><span class="delimiter">&quot;</span></span>},
        { <span class="key"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>: <span class="integer">26</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Alex Jones</span><span class="delimiter">&quot;</span></span>},
        { <span class="key"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>: <span class="integer">19</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Lisa Smith</span><span class="delimiter">&quot;</span></span>}
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然而在 <em>Lucene</em> 中，上述文件会被扁平化存储，最后可能会像下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">followers.age</span><span class="delimiter">&quot;</span></span>:    [<span class="integer">19</span>, <span class="integer">26</span>, <span class="integer">35</span>],
    <span class="key"><span class="delimiter">&quot;</span><span class="content">followers.name</span><span class="delimiter">&quot;</span></span>:   [alex, jones, lisa, smith, mary, white]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{age: 35}`与</code>{name: Mary White}`之间的关联会消失，因每个多值的栏位会变成一个值集合，而非有序的阵列。 这让我们可以知道：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>是否有26岁的追随者？</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但我们无法取得准确的资料如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>是否有26岁的追随者且名字叫Alex Jones？</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>关联内部对象可解决此类问题，我们称之为_嵌套_对象，我们之後会在嵌套对象中提到它。</p>
</div>
</div>
</div>
</div>
<h1 id="_结构化查询" class="sect0"><a class="anchor" href="#_结构化查询"></a>结构化查询</h1>
<div class="sect1">
<h2 id="_空搜索"><a class="anchor" href="#_空搜索"></a>34. 空搜索</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">A GET Request with a Body?</div>
<div class="paragraph">
<p>一般来说，GET请求是不会有请求体的。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://tools.ietf.org/html/rfc7231#page-24">RFC 7231</a> 中，并没有定义一个 <em>GET</em> 请求包含请求体时是什么样的。而有些服务端支持 <em>GET</em> 请求带请求体，有些则不支持。</p>
</div>
<div class="paragraph">
<p><em>ES</em> 作者更喜欢使用 <em>GET</em> 带请求体的方式，因为 <em>GET</em> 这个动词比 <em>POST</em> 更能说明这个检索的动作。不过 <em>GET</em> 带请求体的方式并不通用，所以 search 操作也支持 <em>POST</em> 请求。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">POST /_search
{
  <span class="string"><span class="delimiter">&quot;</span><span class="content">from</span><span class="delimiter">&quot;</span></span>: <span class="integer">30</span>,
  <span class="string"><span class="delimiter">&quot;</span><span class="content">size</span><span class="delimiter">&quot;</span></span>: <span class="integer">10</span>
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_query_dsl"><a class="anchor" href="#_query_dsl"></a>35. Query DSL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Query DSL 是 <em>ES</em> 使用的一个强大的搜索语言，通过简单地 <em>JSON</em> 格式来表示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">elasticsearch</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <em>bool</em> 查询组合多个查询。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p><em>bool</em> 查询在 <em>2.x</em> 版本中添加了 filter context</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span>:     { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">elasticsearch</span><span class="delimiter">&quot;</span></span> }},
        <span class="key"><span class="delimiter">&quot;</span><span class="content">must_not</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>:  <span class="string"><span class="delimiter">&quot;</span><span class="content">mary</span><span class="delimiter">&quot;</span></span> }},
        <span class="key"><span class="delimiter">&quot;</span><span class="content">should</span><span class="delimiter">&quot;</span></span>:   { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">full text</span><span class="delimiter">&quot;</span></span> }},
        <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span>:   { <span class="key"><span class="delimiter">&quot;</span><span class="content">range</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">gt</span><span class="delimiter">&quot;</span></span> : <span class="integer">30</span> }} }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>bool</em> 查询中, <em>must</em> 等后面，要么是一个 <em>json</em> 对象，要么是一个 <em>json</em> 数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>:   { <span class="key"><span class="delimiter">&quot;</span><span class="content">email</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">business opportunity</span><span class="delimiter">&quot;</span></span> }},
        <span class="key"><span class="delimiter">&quot;</span><span class="content">should</span><span class="delimiter">&quot;</span></span>: [
            { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>:       { <span class="key"><span class="delimiter">&quot;</span><span class="content">starred</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span> }},
            { <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span>: {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span>:      { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">folder</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">inbox</span><span class="delimiter">&quot;</span></span> }},
                <span class="key"><span class="delimiter">&quot;</span><span class="content">must_not</span><span class="delimiter">&quot;</span></span>:  { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">spam</span><span class="delimiter">&quot;</span></span>: <span class="value">true</span> }}
            }}
        ],
        <span class="key"><span class="delimiter">&quot;</span><span class="content">minimum_should_match</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_查询_vs_过滤"><a class="anchor" href="#_查询_vs_过滤"></a>36. 查询 VS 过滤</h2>
<div class="sectionbody">
<div class="paragraph">
<p>过滤查询现在移到了 <em>bool</em> 查询的 <em>filter</em> 中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">查询与过滤的主要区别在于</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>查询时需要计算匹配相关度，而过滤时则不考虑这个</p>
</li>
<li>
<p>查询时不会缓存结果，而过滤时会缓存结果</p>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">何时使用查询或过滤</dt>
<dd>
<p>一般的全文检索需要计算匹配相关度的，即要按相关度排序的，那么就使用查询。其它的情况则全部使用过滤就行了。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_基本查询"><a class="anchor" href="#_基本查询"></a>37. 基本查询</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_匹配所有"><a class="anchor" href="#_匹配所有"></a>37.1. 匹配所有</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">match_all</span><span class="delimiter">&quot;</span></span>: {}}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_匹配查询"><a class="anchor" href="#_匹配查询"></a>37.2. 匹配查询</h3>
<div class="paragraph">
<p>匹配查询碰到需要分词的字段时，会分词后匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">About Search</span><span class="delimiter">&quot;</span></span> }}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多字段匹配"><a class="anchor" href="#_多字段匹配"></a>37.3. 多字段匹配</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">multi_match</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">full text search</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">fields</span><span class="delimiter">&quot;</span></span>:   [ <span class="string"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">body</span><span class="delimiter">&quot;</span></span> ]
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_范围匹配"><a class="anchor" href="#_范围匹配"></a>37.4. 范围匹配</h3>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">range</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">gte</span><span class="delimiter">&quot;</span></span>:  <span class="integer">20</span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">lt</span><span class="delimiter">&quot;</span></span>:   <span class="integer">30</span>
        }
    }
}</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
gt
</td>
<td class="hdlist2">
<p>大于</p>
</td>
</tr>
<tr>
<td class="hdlist1">
gte
</td>
<td class="hdlist2">
<p>大于等于</p>
</td>
</tr>
<tr>
<td class="hdlist1">
lt
</td>
<td class="hdlist2">
<p>小于</p>
</td>
</tr>
<tr>
<td class="hdlist1">
lte
</td>
<td class="hdlist2">
<p>小于等于</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_词查询"><a class="anchor" href="#_词查询"></a>37.5. 词查询</h3>
<div class="paragraph">
<p>词查询用于精确查询，词查询就是词与词的匹配。用于 <em>date</em> 、 <em>numbers</em> 、 <em>Booleans</em> 及 <strong>not_analyzed</strong> 的 <em>string</em> 字段。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>:    <span class="integer">26</span>           }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>:   <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-09-01</span><span class="delimiter">&quot;</span></span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">public</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">true</span>         }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">tag</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">full_text</span><span class="delimiter">&quot;</span></span>  }}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多词查询"><a class="anchor" href="#_多词查询"></a>37.6. 多词查询</h3>
<div class="paragraph">
<p>类似于词查询，不过它同时允许指定多个词进行匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">terms</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">tag</span><span class="delimiter">&quot;</span></span>: [ <span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">full_text</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">nosql</span><span class="delimiter">&quot;</span></span> ] }}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_存在与否查询"><a class="anchor" href="#_存在与否查询"></a>37.7. 存在与否查询</h3>
<div class="paragraph">
<p>类似于 <em>SQL</em> 中的 is null 或 is not null</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">exists</span><span class="delimiter">&quot;</span></span>:   { <img src="./images/icons/callouts/1.png" alt="1">
        <span class="key"><span class="delimiter">&quot;</span><span class="content">field</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>不存在，用 missing</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 <em>SQL</em> 中就是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="keyword">where</span> title <span class="keyword">is</span> <span class="keyword">not</span> <span class="predefined-constant">null</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_常量_固定_分数查询"><a class="anchor" href="#_常量_固定_分数查询"></a>37.8. 常量（固定）分数查询</h3>
<div class="paragraph">
<p>并不常用，这个查询就是对所有的文档应用一个固定的匹配分数，默认为 _score=1。它经常用于执行一个过滤查询（因为不关心匹配度）。</p>
</div>
<div class="paragraph">
<p>可以使用下面这个查询代替只有一个filter的 <em>bool</em> 查询，两者性能是一样的，只是这种比较简洁。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>:{
        <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span>:   {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span>: {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">really</span><span class="delimiter">&quot;</span></span> }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_验证查询"><a class="anchor" href="#_验证查询"></a>38. 验证查询</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用 <em>Query DSL</em> 时，有时可能会写错。使用如下语法可以测试是否写错。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /gb/tweet/_validate/query?explain
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span> : {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">really powerful</span><span class="delimiter">&quot;</span></span>
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>给出的验证结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">valid</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span>,   <img src="./images/icons/callouts/1.png" alt="1">
   <span class="key"><span class="delimiter">&quot;</span><span class="content">_shards</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">successful</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">failed</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>
   },
   <span class="key"><span class="delimiter">&quot;</span><span class="content">explanations</span><span class="delimiter">&quot;</span></span>: [
      {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">gb</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">valid</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">error</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">org.elasticsearch.index.query.QueryParsingException: No query registered for [tweet]</span><span class="delimiter">&quot;</span></span>  <img src="./images/icons/callouts/2.png" alt="2">
      }
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>验证结果为 <em>false</em> ，即验证失败</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>失败的原因</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>上面写错了，是把 <em>match</em> 和 <em>tweet</em> 位置上写反了。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">理解查询</dt>
<dd>
<p>通过在查询请求后面添加查询参数 <em>explain</em> ，可以看出查询请求是如何被解析的。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?explain
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">elasticsearch</span><span class="delimiter">&quot;</span></span>
      }
   }
}

GET /_validate/query?explain
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span> : {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">really powerful</span><span class="delimiter">&quot;</span></span>
      }
   }
}</code></pre>
</div>
</div>
</div>
</div>
<h1 id="_排序" class="sect0"><a class="anchor" href="#_排序"></a>排序</h1>
<div class="openblock partintro">
<div class="content">
默认情况下，查询都是按匹配度倒序排序的，也就是说匹配度最高的优先返回了。
</div>
</div>
<div class="sect1">
<h2 id="_默认排序"><a class="anchor" href="#_默认排序"></a>39. 默认排序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>默认排序是按照文档的匹配相关度进行排序的。在 <em>ES</em> 中使用 <strong>_score</strong> 字段来表示文档匹配的相关度，所以默认的排序是按照 <strong>_score</strong> 倒序排序的。</p>
</div>
<div class="paragraph">
<p>有时，可能并不关心文档匹配度排序，这时可以使用过滤查询。例如，过滤查询所有 user_id 为1的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span> : <span class="integer">1</span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这时，返回的所有结果数据的 <strong>_score</strong> 都为0</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">us</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">14</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span>: <span class="integer">0</span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
     <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-09-24</span><span class="delimiter">&quot;</span></span>,
     <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">John Smith</span><span class="delimiter">&quot;</span></span>,
     <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">How many more cheesy tweets do I have to write?</span><span class="delimiter">&quot;</span></span>,
     <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果上面这个得分为0不是很好理解，可以使用 constant_score 查询，其查询结果得分全为1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span> : <span class="integer">1</span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_根据字段进行排序"><a class="anchor" href="#_根据字段进行排序"></a>40. 根据字段进行排序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如指定 <em>date</em> 字段倒序排序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span> : <span class="integer">1</span> }}
        }
    },
    <span class="key"><span class="delimiter">&quot;</span><span class="content">sort</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">order</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">desc</span><span class="delimiter">&quot;</span></span> }}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应结果</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">total</span><span class="delimiter">&quot;</span></span> :           <span class="integer">6</span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">max_score</span><span class="delimiter">&quot;</span></span> :       <span class="predefined-constant">null</span>, <img src="./images/icons/callouts/1.png" alt="1">
    <span class="key"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : [ {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span> :      <span class="string"><span class="delimiter">&quot;</span><span class="content">us</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span> :       <span class="string"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :         <span class="string"><span class="delimiter">&quot;</span><span class="content">14</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :      <span class="predefined-constant">null</span>, <img src="./images/icons/callouts/1.png" alt="1">
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> :     {
             <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>:    <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-09-24</span><span class="delimiter">&quot;</span></span>,
             ...
        },
        <span class="key"><span class="delimiter">&quot;</span><span class="content">sort</span><span class="delimiter">&quot;</span></span> :        [ <span class="integer">1411516800000</span> ] <img src="./images/icons/callouts/2.png" alt="2">
    },
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td><strong>_score</strong> 没有计算，因为没有用 <strong>_score</strong> 作为排序字段</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>该时间字段的值被转换为 <em>ms</em> 了，然后再排序的。</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>由于计算相关度得分是非常耗时的操作，所以在未指定 <strong>_score</strong> 为排序字段时就没有计算相关度得分。</p>
</div>
<div class="paragraph">
<p>如果这种情况下你仍然需要计算相关度得分，在查询请求后面添加查询参数 <strong>track_scores=true</strong> 即可。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_多级排序"><a class="anchor" href="#_多级排序"></a>41. 多级排序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>多级排序指的就是按照多个字段进行排序，类似于 <em>SQL</em> 中的 <code>order by time desc,num asc</code> 这种。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span>:   { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">manage text search</span><span class="delimiter">&quot;</span></span> }},
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span> : <span class="integer">2</span> }}
        }
    },
    <span class="key"><span class="delimiter">&quot;</span><span class="content">sort</span><span class="delimiter">&quot;</span></span>: [  <img src="./images/icons/callouts/1.png" alt="1">
        { <span class="key"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>:   { <span class="key"><span class="delimiter">&quot;</span><span class="content">order</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">desc</span><span class="delimiter">&quot;</span></span> }},
        { <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">order</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">desc</span><span class="delimiter">&quot;</span></span> }}
    ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>先根据 <em>date</em> 降序排序，再根据 <strong>_score</strong> 降序排序</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>query-string</em> 中也可以指定排序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?sort=date:desc&amp;sort=_score&amp;q=search</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_多值字段排序"><a class="anchor" href="#_多值字段排序"></a>42. 多值字段排序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当一个字段有多个值时，如该字段为一个数组。此时如果对该字段进行排序，则需要指定按照这个数组中的哪一个值进行排序呢。</p>
</div>
<div class="paragraph">
<p>如 <em>dates</em> 为一个日期数组字段。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">sort</span><span class="delimiter">&quot;</span></span>: {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">dates</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">order</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">asc</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">mode</span><span class="delimiter">&quot;</span></span>:  <span class="string"><span class="delimiter">&quot;</span><span class="content">min</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/1.png" alt="1">
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>支持的模式包括：<code>min</code>,<code>max</code>,<code>avg</code>,<code>sum</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_string_字段排序"><a class="anchor" href="#_string_字段排序"></a>43. String 字段排序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>被分词的字段也可以说是多值的，要是直接对 <em>analyzed</em> 的字段进行排序的话，通常得到的结果并不是你想要的。</p>
</div>
<div class="paragraph">
<p>例如该字段有一个值为 “fine old art” ，被分词后就是三个值了，此时如何想按 <code>fine</code> 排序怎么办？如果说使用 <em>min</em> 模式，那么按字母顺序就是按 <code>art</code> 进行排序了，按 <em>max</em> 就是 <code>old</code> 了。</p>
</div>
<div class="paragraph">
<p>为了对一个 <em>string</em> 字段进行排序，这个字段必须为单个词才方便排序，即 <strong>not_analyzed</strong> 。但是我们又希望这个字段可以被搜索（需要该字段 <em>analyzed</em> ）。</p>
</div>
<div class="paragraph">
<p>最简单的做法是同一个字段存储为两个字段，一个字段分词，一个字段不分词。但是这种做法会造成存储空间的浪费。</p>
</div>
<div class="paragraph">
<p>其实此时我们只需要对同一个字段按照两种不同的索引方式索引即可。</p>
</div>
<div class="listingblock">
<div class="title">tweet之前的索引方式</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">analyzer</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">english</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">tweet的2种索引方式</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,  <img src="./images/icons/callouts/1.png" alt="1">
    <span class="key"><span class="delimiter">&quot;</span><span class="content">analyzer</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">english</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">fields</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">raw</span><span class="delimiter">&quot;</span></span>: { <img src="./images/icons/callouts/2.png" alt="2">
            <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:  <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">not_analyzed</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td><code>tweet</code> 字段同先前一样，分词字段，可以被检索</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td><code>tweet.raw</code> 作为子字段，不分词</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在就可以对 <code>tweet.raw</code> 字段进行排序了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">elasticsearch</span><span class="delimiter">&quot;</span></span>
        }
    },
    <span class="key"><span class="delimiter">&quot;</span><span class="content">sort</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">tweet.raw</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="./images/icons/warning.png" alt="Warning">
</td>
<td class="content">
<div class="paragraph">
<p>不要直接对分词字段进行排序，会很耗内存的。</p>
</div>
<div class="paragraph">
<p>分词字段的排序，应使用上面推荐的方法。即新增一个不分词的子字段。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_什么是相关度"><a class="anchor" href="#_什么是相关度"></a>44. 什么是相关度</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在你搜索时，搜索结果中的每一个文档都有一个相关度评分，被称为 <strong>_score</strong> ，这个字段用一个正的浮点数表示，值越大，说明文档越匹配。</p>
</div>
<div class="paragraph">
<p>文档的相关度匹配跟你用的查询语句有很大的关系，如 <code>fuzzy</code> 查询会计算文档与搜索词的拼写相似程度，而 <code>terms</code> 查询则计算词命中了多少次。</p>
</div>
<div class="paragraph">
<p>在 <em>ES</em> 中计算文档相关度，使用的算法称为 <em>term frequency/inverse document frequency</em> ，即 <em>TF/IDF</em> ，这个算法主要依据下面3个方面来计算相关度。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">词频率</dt>
<dd>
<p>即你搜索的词出现在该字段中的频率，频率越高，自然相关度越高。</p>
</dd>
<dt class="hdlist1">反向文档频率</dt>
<dd>
<p>即你搜索的词在这个索引中（所有的文档中）出现的频率，如果这个词越频繁，说明这个词越不重要（如一些语气词），那么相关度就越低。</p>
</dd>
<dt class="hdlist1">字段长度准则</dt>
<dd>
<p>这个就是看你匹配的字段内容长度，例如一个 <em>title</em> 字段命中该词比一个 <em>content</em> 字段命中该词后的相关度要高。因为明显 <em>title</em> 字段比 <em>content</em> 字段中的内容长度要小。</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_理解相关度评分"><a class="anchor" href="#_理解相关度评分"></a>44.1. 理解相关度评分</h3>
<div class="paragraph">
<p>当使用了一个复杂的查询时，一般是很难理解 <strong><em>score</strong> 是如何计算出来的。此时可以在查询请求后面添加 _explain</em> 参数来让 <em>ES</em> 产生一个评分计算的说明。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?explain
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>   : { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">honeymoon</span><span class="delimiter">&quot;</span></span> }}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>响应的解释信息</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">_explanation</span><span class="delimiter">&quot;</span></span>: { <img src="./images/icons/callouts/1.png" alt="1">
   <span class="key"><span class="delimiter">&quot;</span><span class="content">description</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">weight(tweet:honeymoon in 0)
                  [PerFieldSimilarity], result of:</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>:       <span class="float">0.076713204</span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">details</span><span class="delimiter">&quot;</span></span>: [
      {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">description</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">fieldWeight in 0, product of:</span><span class="delimiter">&quot;</span></span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>:       <span class="float">0.076713204</span>,
         <span class="key"><span class="delimiter">&quot;</span><span class="content">details</span><span class="delimiter">&quot;</span></span>: [
            {  <img src="./images/icons/callouts/2.png" alt="2">
               <span class="key"><span class="delimiter">&quot;</span><span class="content">description</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">tf(freq=1.0), with freq of:</span><span class="delimiter">&quot;</span></span>,
               <span class="key"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>:       <span class="integer">1</span>,
               <span class="key"><span class="delimiter">&quot;</span><span class="content">details</span><span class="delimiter">&quot;</span></span>: [
                  {
                     <span class="key"><span class="delimiter">&quot;</span><span class="content">description</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">termFreq=1.0</span><span class="delimiter">&quot;</span></span>,
                     <span class="key"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>:       <span class="integer">1</span>
                  }
               ]
            },
            { <img src="./images/icons/callouts/3.png" alt="3">
               <span class="key"><span class="delimiter">&quot;</span><span class="content">description</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">idf(docFreq=1, maxDocs=1)</span><span class="delimiter">&quot;</span></span>,
               <span class="key"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>:       <span class="float">0.30685282</span>
            },
            { <img src="./images/icons/callouts/4.png" alt="4">
               <span class="key"><span class="delimiter">&quot;</span><span class="content">description</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">fieldNorm(doc=0)</span><span class="delimiter">&quot;</span></span>,
               <span class="key"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>:        <span class="float">0.25</span>,
            }
         ]
      }
   ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>解释说明的摘要。weight(tweet:honeymoon in 0) 即计算词 honeymoon 在字段 tweet 上的权重，在文档0（内部的文档ID，此处可以忽略）中</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>词频率。 词 honeymoon 在字段 tweet 的值中出现了多少次</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>反向文档频率。 词 honeymoon 在该索引下所有文档中的 tweet 字段的值中出现多少次。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/4.png" alt="4"></td>
<td>字段长度标准。 在该文档中 tweet 这个字段的值的长度占比。</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="./images/icons/warning.png" alt="Warning">
</td>
<td class="content">
<div class="paragraph">
<p>产生 <em>explain</em> 信息是很耗性能的，所以这个操作只应该用于调试，生产系统造成不要开启 <em>explain</em></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_理解为什么某一文档匹配上了"><a class="anchor" href="#_理解为什么某一文档匹配上了"></a>44.2. 理解为什么某一文档匹配上了</h3>
<div class="paragraph">
<p>可以使用 <em>explain</em> API来理解文档为什么会被匹配或匹配不上。</p>
</div>
<div class="paragraph">
<p>例如，想看下 /us/tweet/12 这个文档为什么用下面的查询匹配不上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /us/tweet/<span class="integer">12</span>/_explain
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> :  { <span class="key"><span class="delimiter">&quot;</span><span class="content">user_id</span><span class="delimiter">&quot;</span></span> : <span class="integer">2</span>           }},
         <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span> :  { <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">tweet</span><span class="delimiter">&quot;</span></span> :   <span class="string"><span class="delimiter">&quot;</span><span class="content">honeymoon</span><span class="delimiter">&quot;</span></span> }}
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>省略一长串解释信息后，可以看到返回结果中明确说明了为什么不匹配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">user_id: 12 doesn't match id 2</span><span class="delimiter">&quot;</span></span>,</code></pre>
</div>
</div>
<div class="paragraph">
<p>也就是说，上面的 "user_id" 过滤器阻止了文档被匹配上</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_doc_values_介绍"><a class="anchor" href="#_doc_values_介绍"></a>45. Doc Values 介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当我们对一个字段进行排序时， <em>ES</em> 需要访问所有的匹配到查询的文档中的该字段的值。倒排索引，对于检索来说是非常棒的一个数据结构，但是对于排序来说并不适合。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当搜索时，我们用词来关联文档。（倒排索引）</p>
</li>
<li>
<p>当排序时，我们需要用文档来关联它的词。（非倒排索引，传统数据库模式）</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/doc_value.png" alt="doc value">
</div>
<div class="title">Figure 9. 字段排序结构图</div>
</div>
<div class="paragraph">
<p>上图中，最终演变为了列存储的结构。在 <em>ES</em> 中，这种列存储也被称为 <em>doc values</em> ，它是默认开启的。 <em>Doc values</em> 在索引数据时创建：当一个字段数据插入时， <em>ES</em> 不光把这种词与文档的映射关系添加到倒排索引，同时还把该字段数据对应的词添加到对应的字段列的 <em>doc values</em> 中。</p>
</div>
<div class="paragraph">
<p>在 <em>ES</em> 中， <em>doc values</em> 主要用于以下几处：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对字段进行排序</p>
</li>
<li>
<p>对字段进行聚合（按字段分组）</p>
</li>
<li>
<p>某些过滤器（如地理位置过滤器）</p>
</li>
<li>
<p>针对字段操作的脚本</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><em>Doc values</em> 是存储在硬盘上的，所以 <em>ES</em> 在节点内存空余时会将 <em>doc values</em> 加载到内存中以实现快速访问，如果节点内存不足时，则会直接在硬盘上读取。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>Doc values</em> 加载时会将整个字段对应的数据全部加载进来，而非仅仅你的查询匹配的数据。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<h1 id="_深入理解分布式搜索过程" class="sect0"><a class="anchor" href="#_深入理解分布式搜索过程"></a>深入理解分布式搜索过程</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>分布式搜索比基本的分布式 CRUD 请求（分布式文档存储中提过） 要复杂的多。</p>
</div>
<div class="paragraph">
<p>CRUD 请求时都会有文档的 index、type、id 及路由值等，所以我们可以确定集群中哪一个分片上有这个文档。</p>
</div>
<div class="paragraph">
<p>而搜索请求就更复杂了，因为我们并不知道哪些文档会匹配你的查询，而且匹配的文档可能在集群中的任意一个分片上。所以一个查询请求需要去请求索引上的每一个 <strong>分片（这里指主或备分片中任意一个）</strong> ，然后来看是否有文档匹配到上你的查询。</p>
</div>
<div class="paragraph">
<p>但是从所有分片（主或备中任意一个）中找出匹配上查询的文档只是第一步，每个分片上匹配到的文档还需要合并到一起，然后再按照分页取出某一页数据返回。因为这个原因，所以一个搜索请求分为两步：查询数据与获取数据。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_查询数据阶段"><a class="anchor" href="#_查询数据阶段"></a>46. 查询数据阶段</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在初始化查询阶段时，搜索请求被广播到所有的分片（任意一个主或备份分片）上。每一个分片本地执行这个搜索请求，然后将匹配的文档放入到一个带优先级的队列中。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Priority Queue</div>
<div class="paragraph">
<p>一个带优先级的队列就是保存top-n（最匹配的N条）个匹配文档的队列。而这个队列的大小取决于查询请求中的 <em>from</em> 与 <em>size</em> 。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">from</span><span class="delimiter">&quot;</span></span>: <span class="integer">90</span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">size</span><span class="delimiter">&quot;</span></span>: <span class="integer">10</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>则队列的大小为 <strong>from+size=100</strong> 。这里要取 <strong>from+size</strong> 是因为每个分片上取完数据后还需要排序的原因。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>因为最终排序的关系，绝大部分数据会丢弃。优先级队列中为了减小空间占用，只存储了匹配到的文档的 <em>docId</em> 与 <em>sort value</em> 。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_0901.png" alt="elas 0901">
</div>
<div class="title">Figure 10. 分布式检索查询阶段</div>
</div>
<div class="olist arabic">
<div class="title">上图可以用以下3个步骤描述：</div>
<ol class="arabic">
<li>
<p>客户端发送搜索请求到节点3， 节点3此时创建一个空的带优先级队列，队列大小为 <strong>from+size</strong></p>
</li>
<li>
<p>节点3将请求转发到索引中每一个分片（主或备份分片）上，每一个分片本地执行搜索请求并将匹配的结果放到它本地的优先级队列（大小同样为 <strong>from+size</strong> ）中。</p>
</li>
<li>
<p>每一个分片将优先级队列中 <em>docIds</em> 与 <em>sort values</em> 返回给对应的协调节点（节点3），节点3然后将所有的请求合并到它自己的优先级队列中形成一个按排序值排好序的全局队列。</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>跟客户端通讯的节点，也被称为协调节点，例如上面的节点3。协调节点需要转发请求到所有分片，而且需要收集所有分片返回的数据，再根据分页设置取出对应的数据并返回给客户端。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>协调节点转发请求至各分片（主或备）时采用轮循机制，就是在主或备之间轮循以确保能平摊压力。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>协调节点将所有分片上的数据合并到自己的优先队列中并形成一个全局的排好序的文档集合后，查询阶段就完成了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_获取数据阶段"><a class="anchor" href="#_获取数据阶段"></a>47. 获取数据阶段</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由于在查询阶段，优先级队列中只存储了 <em>docIds</em> 与 <em>sort value</em> ，所以还需要根据 <em>docIds</em> 去获取真正的数据。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_0902.png" alt="elas 0902">
</div>
<div class="title">Figure 11. 分布式搜索获取数据阶段</div>
</div>
<div class="olist arabic">
<div class="title">分布式搜索获取数据阶段由以下几个步骤组成：</div>
<ol class="arabic">
<li>
<p>协调节点决定由哪些文档是真正需要获取的，根据 <em>docIds</em> 发送一个 <em>MGet</em> 请求至各个相关的分片。</p>
</li>
<li>
<p>所有的相关分片获取到对应的文档（填充 _source， 填充高亮片段）后，将文档返回给对应的协调节点</p>
</li>
<li>
<p>当所有的分片将文档都返回后，协调节点再将结果一起返回给客户端</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>协调节点最先处理的是要决定哪些文档才是真正需要去获取的。比如你的查询指定的是 {"from":90,"size":10} ，那就意味着最开始的90个文档都需要被丢弃，你只需要下10个文档。然后协调节点只需要发送 <em>MGet</em> 请求获取这10个文档即可。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">深层分页</div>
<div class="paragraph">
<p>搜索支持 <em>from</em> 与 <em>size</em> 参数，但是有些限制。在上面的查询阶段提到过，每一个分片都自己建立了一个优先级队列，大小为 <strong>from+size</strong> ，然后队列所有数据需要返回给协调节点。然后协调节点需要对 <strong>number_of_shards * (from + size)</strong> 个文档进行排序，再从排序好的文档列表中，找到 <em>from</em> 与 <em>size</em> 指定的那些文档。</p>
</div>
<div class="paragraph">
<p>这个时候分页限制就取决于你指定的 <em>from</em> 和 <em>size</em> 大小，以及 <strong>number_of_shards</strong>（主分片数量）和你的硬件了。分页越深，耗费的 CPU 、 内存、 带宽越大。 出于这个原因，应该尽量避免深分页。</p>
</div>
<div class="paragraph">
<p>一般情况下，人们用搜索时一般只分翻几页后就换一个其它的条件来检索了，也就是说人为地去深分页概率比较低。一般来说，只有黑客与网页爬虫才会去深分页让你的服务器崩溃。</p>
</div>
<div class="paragraph">
<p>如果你需要从你的集群中获取大量的文档，此时建议使用 <em>scroll</em> 查询（它会禁用排序）。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_查询参数"><a class="anchor" href="#_查询参数"></a>48. 查询参数</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一些查询参数可以影响搜索过程</p>
</div>
<div class="sect2">
<h3 id="_preference"><a class="anchor" href="#_preference"></a>48.1. preference</h3>
<div class="paragraph">
<p><em>preference</em> 参数可以用来决定由哪些分片来处理你的查询请求。它接受的参数值有：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/preference.png" alt="preference">
</div>
</div>
<div class="paragraph">
<p>然而，上面的参数值中最常用的是 Custom value ，来避免结果跳动。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bouncing Results</div>
<div class="paragraph">
<p>假设你根据 <em>timestamp</em> 字段进行排序，现在有2个文档拥有相同的 <em>timestamp</em> 。 因为查询请求都是在可用的主、备分片上轮循的，所以就可能出现这2个文档在主分片中是一种顺序，在备份分片中又是一种顺序。</p>
</div>
<div class="paragraph">
<p>这个就是结果跳动的情况，每当用户刷新他的页面，返回的结果是不同的顺序。这个问题可以用 <em>preference</em> 参数指定自定义的字符串来避免，例如指定用户的 <em>session id</em> ，这样用户每次访问都是在同一个分片上。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_timeout_2"><a class="anchor" href="#_timeout_2"></a>48.2. timeout</h3>
<div class="paragraph">
<p>默认情况下，分片都是各自处理匹配到的数据，然后返回给协调节点，由协调节点依次合并所有结果。</p>
</div>
<div class="paragraph">
<p>这也就是说，一个搜索请求的耗时由处理请求最慢的分片（多个分片处理请求是并行的）耗时加上最后合并结果耗时组成。</p>
</div>
<div class="paragraph">
<p><em>timeout</em> 参数用于告诉分片在返回数据给协调节点前它们有多长时间用来处理数据，这也就是说，如果没有足够的时间处理所有数据，这个分片将会放弃剩余的数据直接将已处理的数据返回给协调节点（有可能压根都没有已处理数据）。</p>
</div>
<div class="paragraph">
<p>在搜索的响应信息中可以看出查询请求是否超时了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"> <span class="string"><span class="delimiter">&quot;</span><span class="content">timed_out</span><span class="delimiter">&quot;</span></span>:     <span class="predefined-constant">true</span> <img src="./images/icons/callouts/1.png" alt="1"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>为 <em>true</em> 表示超时了</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="./images/icons/warning.png" alt="Warning">
</td>
<td class="content">
<div class="paragraph">
<p><em>timeout</em> 只是一个尽力而为的操作，这里也是有可能有些查询耗时还是会超过分配的 <em>timeout</em> 时间。主要有下面两种方式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Timeout 检查是基于每一个文档的。然而，有一些查询类型在对文档进行匹配之前要做大量的准备工作，而这些准备工作消耗的时间是不会计算在 <em>timeout</em> 之内的，所以这些准备工作耗时太长时将会使查询耗时超过分配的 <em>timeout</em> 时间。</p>
</li>
<li>
<p>因为 Timeout 检查是基于每个文档的，所以就有可能上一个文档的匹配计算耗时太长，直到下一文档被计算时才会检查是否超时。例如，此时如果上一文档执行了写的脚本（该脚本中有个死循环），那么这种情况下，就会一直卡死在那， <em>timeout</em> 也不会起作用。</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_routing"><a class="anchor" href="#_routing"></a>48.3. routing</h3>
<div class="paragraph">
<p>在 “分布式文档存储章节” ，我们讲过自定义路由参数可以在索引数据时决定文档存储到哪些分片上。在搜索时，为避免在所有分片上找匹配文档，你也可以指定路由参数来决定在指定的分片上查找匹配的文档。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?routing=user_1,user2</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个技术通常用于超大的搜索系统来提高搜索效率。</p>
</div>
</div>
<div class="sect2">
<h3 id="_search_type"><a class="anchor" href="#_search_type"></a>48.4. search_type</h3>
<div class="paragraph">
<p>默认的搜索类型为 <code>query_then_fetch</code> 。有时，你可能希望明确指定搜索类型为 <code>dfs_query_then_fetch</code> 来提高相关度评分的准确性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search?search_type=dfs_query_then_fetch</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>dfs_query_then_fetch</code> 会有一个预查询阶段，它会从所有涉及到的分片中提取词频率然后再算全局的词频率。后面会深入讲解。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_scroll"><a class="anchor" href="#_scroll"></a>49. Scroll</h2>
<div class="sectionbody">
<div class="paragraph">
<p>滚动查询用于高效地从 <em>ES</em> 中获取大部分数据，它不会排序也不会深分页。</p>
</div>
<div class="paragraph">
<p><em>Scrolling</em> 允许我们初始化一个查询并且持续一批批地从 <em>ES</em> 中取数据。</p>
</div>
<div class="paragraph">
<p>深分页的主要性能损耗在于对结果集的全局排序，但是如果我们禁用了排序，那么将以非常廉价的性能损耗获取到所有的文档。为了禁用排序，我们对 <code>_doc</code> 字段进行排序（不指定排序时，默认是以 <code>_score</code> 进行排序）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /old_index/_search?scroll=<span class="integer">1</span>m <img src="./images/icons/callouts/1.png" alt="1">
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">match_all</span><span class="delimiter">&quot;</span></span>: {}},
    <span class="key"><span class="delimiter">&quot;</span><span class="content">sort</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">_doc</span><span class="delimiter">&quot;</span></span>], <img src="./images/icons/callouts/2.png" alt="2">
    <span class="key"><span class="delimiter">&quot;</span><span class="content">size</span><span class="delimiter">&quot;</span></span>:  <span class="integer">1000</span> <img src="./images/icons/callouts/3.png" alt="3">
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>保持滚动窗口1分钟，1分钟后将自动清除资源。意味着过1分钟后，你再拿返回的 <strong>scroll_id</strong> 去取数据时将取不到。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>按 <strong>_doc</strong> 进行排序</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>指定返回的结果集大小为 1000</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>此时响应将返回一个 <strong>scroll_id</strong> ，然后再根据 <strong>scroll_id</strong> 获取下一批数据即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search/scroll
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">scroll</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">1m</span><span class="delimiter">&quot;</span></span>, <img src="./images/icons/callouts/1.png" alt="1">
    <span class="key"><span class="delimiter">&quot;</span><span class="content">scroll_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">cXVlcnlUaGVuRmV0Y2g7NTsxMDk5NDpkUmpiR2FjOFNhNnlCM1ZDMWpWYnRROzEwOTk1OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MTA5OTM6ZFJqYkdhYzhTYTZ5QjNWQzFqVmJ0UTsxMTE5MDpBVUtwN2lxc1FLZV8yRGVjWlI2QUVBOzEwOTk2OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MDs=</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/2.png" alt="2">
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>再次设置向下滚动的超时时间</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>批处理的ID</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>尽管上面指定了 <em>size</em> 为1000条，但是每一批次里可能返回 <code>size*number_of_primary_shards</code> 个文档回来。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<h1 id="_索引管理" class="sect0"><a class="anchor" href="#_索引管理"></a>索引管理</h1>
<div class="openblock partintro">
<div class="content">
本章将介绍如何管理索引及类型映射，和一些重要的设置。
</div>
</div>
<div class="sect1">
<h2 id="_创建索引"><a class="anchor" href="#_创建索引"></a>50. 创建索引</h2>
<div class="sectionbody">
<div class="paragraph">
<p>先前，我们直接添加一个文档后，会自动根据默认配置创建索引，并且会根据动态映射添加类型映射。现在如果想自已配置主分片个数、分析器等，就需要在索引数据前先配置好索引与类型映射了。</p>
</div>
<div class="paragraph">
<p>手动创建索引。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">settings</span><span class="delimiter">&quot;</span></span>: { ... any settings ... },
    <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">type_one</span><span class="delimiter">&quot;</span></span>: { ... any mappings ... },
        <span class="key"><span class="delimiter">&quot;</span><span class="content">type_two</span><span class="delimiter">&quot;</span></span>: { ... any mappings ... },
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>实际上，如果想禁用默认的动态创建索引的话，可以在集群中的每一个节点上的 <code>conf/elasticsearch.yml</code> 中进行配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="yaml"><span class="key">action.auto_create_index</span>: <span class="string"><span class="content">false</span></span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>在后面的索引模板章节中，会介绍如何预配置索引设置，以便动态创建索引。这在处理日志文件的索引时非常有用。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_删除索引"><a class="anchor" href="#_删除索引"></a>51. 删除索引</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">DELETE /my_index   <img src="./images/icons/callouts/1.png" alt="1"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>删除索引 <code>my_index</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当然，你也可以同时删除多个索引</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">DELETE /index_one,index_two
DELETE /index_*</code></pre>
</div>
</div>
<div class="paragraph">
<p>甚至，可以删除所有的索引</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">DELETE /_all</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者 <code>DELETE /*</code></p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>有时使用上面的操作删除所有索引可能并不安全，可以通过以下配置
<code>action.destructive_requires_name: true</code> 来要求删除索引时必须指定索引名称。 这个配置可以通过集群状态 <em>API</em> 来动态设置。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_索引设置"><a class="anchor" href="#_索引设置"></a>52. 索引设置</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>ES</em> 中有很多配置可以来修改 <em>index</em> 的默认配置，不过一般情况下还是不建议修改这些默认配置，除非你真的知道你在做什么。</p>
</div>
<div class="paragraph">
<p>以下是两个比较重要的配置：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">number_of_shards</dt>
<dd>
<p>主分片的个数，默认为5个。这个配置只能创建索引时指定，一旦索引创建完成后此配置将不能再修改。</p>
</dd>
<dt class="hdlist1">number_of_replicas</dt>
<dd>
<p>备份分片的数量，用来指定每一个主分片可以拥有的 <em>copy</em> 数量。默认为 1 ，这个配置可以动态更新。</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_temp_index
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">settings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">number_of_shards</span><span class="delimiter">&quot;</span></span> :   <span class="integer">1</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">number_of_replicas</span><span class="delimiter">&quot;</span></span> : <span class="integer">0</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，可以通过 <code>update-index-settings</code> 来动态更新</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_temp_index/_settings
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">number_of_replicas</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_配置分析器"><a class="anchor" href="#_配置分析器"></a>53. 配置分析器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>索引设置中第三个重要的配置就是 <code>analysis</code> 了，它用来将现有的分析器组织成新的自定义分析器并应用到你的索引中。</p>
</div>
<div class="paragraph">
<p>在【分析器介绍】中，我们介绍了一些内置的分析器，用于将全文字符串转换为适合搜索的倒排索引。</p>
</div>
<div class="paragraph">
<p><code>standard</code> 分析器是用于全文字段的默认分析器，对于大部分西方语系来说是一个不错的选择。它考虑了以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>standard</code> 分词器，在词层级上分割输入的文本。</p>
</li>
<li>
<p><code>standard</code> 标记过滤器，被设计用来整理分词器触发的所有标记（但是目前什么都没做）。</p>
</li>
<li>
<p><code>lowercase</code> 标记过滤器，将所有标记转换为小写。</p>
</li>
<li>
<p><code>stop</code> 标记过滤器，删除所有可能会造成搜索歧义的停用词，如 <code>a</code>，<code>the</code>，<code>and</code>，<code>is</code>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，停用词过滤器是被禁用的。如需启用它，你可以通过创建一个基于 <code>standard</code> 分析器的自定义分析器，并且设置 <code>stopwords</code> 参数。可以提供一个停用词列表，或者使用一个特定语言的预定停用词列表。</p>
</div>
<div class="paragraph">
<p>在下面的例子中，我们创建了一个新的分析器，叫做 <code>es_std</code>，并使用预定义的西班牙语停用词：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">PUT /spanish_docs

{

    &quot;settings&quot;: {

        &quot;analysis&quot;: {

            &quot;analyzer&quot;: {

                &quot;es_std&quot;: {

                    &quot;type&quot;:      &quot;standard&quot;,

                    &quot;stopwords&quot;: &quot;_spanish_&quot;

                }

            }

        }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>es_std</code> 分析器不是全局的，它仅仅存在于我们定义的 <code>spanish_docs</code> 索引中。为了用 <code>analyze</code> API 来测试它，我们需要使用特定的索引名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">GET /spanish_docs/_analyze?analyzer=es_std

El veloz zorro marrón</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面简化的结果中显示停用词 <code>El</code> 被正确的删除了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">{

  &quot;tokens&quot; : [

    { &quot;token&quot; :    &quot;veloz&quot;,   &quot;position&quot; : 2 },

    { &quot;token&quot; :    &quot;zorro&quot;,   &quot;position&quot; : 3 },

    { &quot;token&quot; :    &quot;marrón&quot;,  &quot;position&quot; : 4 }

  ]

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_自定义分析器"><a class="anchor" href="#_自定义分析器"></a>54. 自定义分析器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>虽然 Elasticsearch 内置了一系列的分析器，但是真正的强大之处在于定制你自己的分析器。你可以通过在配置文件中组合字符过滤器，分词器和标记过滤器，来满足特定数据的需求。</p>
</div>
<div class="paragraph">
<p>在 【分析器介绍】 中，我们提到 <em>分析器</em> 是三个顺序执行的组件的结合（字符过滤器，分词器，标记过滤器）。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">字符过滤器</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>字符过滤器是让字符串在被分词前变得更加“整洁”。例如，如果我们的文本是 HTML 格式，它可能会包含一些我们不想被索引的 HTML 标签，诸如 <code>&lt;p&gt;</code> 或 <code>&lt;div&gt;</code>。</p>
</li>
<li>
<p>我们可以使用 [<code>html_strip</code> 字符过滤器](<a href="http://bit.ly/1B6f4Ay" class="bare">http://bit.ly/1B6f4Ay</a>) 来删除所有的 HTML 标签，并且将 HTML 实体转换成对应的 Unicode 字符，比如将 <code>&amp;Aacute;</code> 转成 <code>Á</code>。</p>
</li>
<li>
<p>一个分析器可能包含零到多个字符过滤器。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">分词器</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>一个分析器 <em>必须</em> 包含一个分词器。分词器将字符串分割成单独的词（terms）或标记（tokens）。<code>standard</code> 分析器使用 [<code>standard</code> 分词器](<a href="http://bit.ly/1E3Fd1b)将字符串分割成单独的字词，删除大部分标点符号，但是现存的其他分词器会有不同的行为特征。" class="bare">http://bit.ly/1E3Fd1b)将字符串分割成单独的字词，删除大部分标点符号，但是现存的其他分词器会有不同的行为特征。</a></p>
</li>
<li>
<p>例如，[<code>keyword</code> 分词器](<a href="http://bit.ly/1ICd585)输出和它接收到的相同的字符串，不做任何分词处理。"><code>whitespace</code> 分词器</a>只通过空格来分割文本。[<code>pattern</code> 分词器]可以通过正则表达式来分割文本。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">词过滤器</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>分词结果的 <em>标记流</em> 会根据各自的情况，传递给特定的标记过滤器。</p>
</li>
<li>
<p>标记过滤器可能修改，添加或删除标记。我们已经提过 <code>lowercase</code> 和 <code>stop</code> 标记过滤器，但是 Elasticsearch 中有更多的选择。<code>stemmer</code> 标记过滤器将单词转化为他们的根形态（root form）。<code>ascii_folding</code> 标记过滤器会删除变音符号，比如从 <code>très</code> 转为 <code>tres</code>。 <code>ngram</code> 和 <code>edge_ngram</code> 可以让标记更适合特殊匹配情况或自动完成。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在【深入搜索】中，我们将举例介绍如何使用这些分词器和过滤器。但是首先，我们需要阐述一下如何创建一个自定义分析器</p>
</div>
<div class="sect2">
<h3 id="_创建自定义分析器"><a class="anchor" href="#_创建自定义分析器"></a>54.1. 创建自定义分析器</h3>
<div class="paragraph">
<p>与索引设置一样，我们预先配置好 <code>es_std</code> 分析器，我们可以再 <code>analysis</code> 字段下配置字符过滤器，分词器和标记过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">PUT /my_index

{

    &quot;settings&quot;: {

        &quot;analysis&quot;: {

            &quot;char_filter&quot;: { ... custom character filters ... },

            &quot;tokenizer&quot;:   { ...    custom tokenizers     ... },

            &quot;filter&quot;:      { ...   custom token filters   ... },

            &quot;analyzer&quot;:    { ...    custom analyzers      ... }

        }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>作为例子，我们来配置一个这样的分析器：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用 <code>html_strip</code> 字符过滤器去除所有的 HTML 标签</p>
</li>
<li>
<p>将 <code>&amp;</code> 替换成 <code>and</code>，使用一个自定义的 <code>mapping</code> 字符过滤器</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">&quot;char_filter&quot;: {

    &quot;&amp;_to_and&quot;: {

        &quot;type&quot;:       &quot;mapping&quot;,

        &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]

    }

}</code></pre>
</div>
</div>
</li>
<li>
<p>使用 <code>standard</code> 分词器分割单词</p>
</li>
<li>
<p>使用 <code>lowercase</code> 标记过滤器将词转为小写</p>
</li>
<li>
<p>用 <code>stop</code> 标记过滤器去除一些自定义停用词。</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">&quot;filter&quot;: {

    &quot;my_stopwords&quot;: {

        &quot;type&quot;:        &quot;stop&quot;,

        &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据以上描述来将预定义好的分词器和过滤器组合成我们的分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">&quot;analyzer&quot;: {

    &quot;my_analyzer&quot;: {

        &quot;type&quot;:           &quot;custom&quot;,

        &quot;char_filter&quot;:  [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],

        &quot;tokenizer&quot;:      &quot;standard&quot;,

        &quot;filter&quot;:       [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>用下面的方式可以将以上请求合并成一条：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">PUT /my_index

{

    &quot;settings&quot;: {

        &quot;analysis&quot;: {

            &quot;char_filter&quot;: {

                &quot;&amp;_to_and&quot;: {

                    &quot;type&quot;:       &quot;mapping&quot;,

                    &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]

            }},

            &quot;filter&quot;: {

                &quot;my_stopwords&quot;: {

                    &quot;type&quot;:       &quot;stop&quot;,

                    &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]

            }},

            &quot;analyzer&quot;: {

                &quot;my_analyzer&quot;: {

                    &quot;type&quot;:         &quot;custom&quot;,

                    &quot;char_filter&quot;:  [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],

                    &quot;tokenizer&quot;:    &quot;standard&quot;,

                    &quot;filter&quot;:       [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]

            }}

}}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;!-- SENSE: 070_Index_Mgmt/20_Custom_analyzer.json -&#8594;</p>
</div>
<div class="paragraph">
<p>创建索引后，用 <code>analyze</code> API 来测试新的分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">GET /my_index/_analyze?analyzer=my_analyzer

The quick &amp; brown fox</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;!-- SENSE: 070_Index_Mgmt/20_Custom_analyzer.json -&#8594;</p>
</div>
<div class="paragraph">
<p>下面的结果证明我们的分析器能正常工作了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">{

  &quot;tokens&quot; : [

      { &quot;token&quot; :   &quot;quick&quot;,    &quot;position&quot; : 2 },

      { &quot;token&quot; :   &quot;and&quot;,      &quot;position&quot; : 3 },

      { &quot;token&quot; :   &quot;brown&quot;,    &quot;position&quot; : 4 },

      { &quot;token&quot; :   &quot;fox&quot;,      &quot;position&quot; : 5 }

    ]

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除非我们告诉 Elasticsearch 在哪里使用，否则分析器不会起作用。我们可以通过下面的映射将它应用在一个 <code>string</code> 类型的字段上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">PUT /my_index/_mapping/my_type

{

    &quot;properties&quot;: {

        &quot;title&quot;: {

            &quot;type&quot;:      &quot;string&quot;,

            &quot;analyzer&quot;:  &quot;my_analyzer&quot;

        }

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_类型与映射"><a class="anchor" href="#_类型与映射"></a>55. 类型与映射</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>类型</em> 在 Elasticsearch 中表示一组相似的文档。<em>类型</em> 由一个 <em>名称</em>（比如 <code>user</code> 或 <code>blogpost</code>）和一个类似数据库表结构的映射组成，描述了文档中可能包含的每个字段的 <em>属性</em>，数据类型（比如 <code>string</code>, <code>integer</code> 或 <code>date</code>），和是否这些字段需要被 Lucene 索引或储存。</p>
</div>
<div class="sect2">
<h3 id="_lucene如何处理文档"><a class="anchor" href="#_lucene如何处理文档"></a>55.1. Lucene如何处理文档</h3>
<div class="paragraph">
<p>在 <em>Lucene</em> 中，一个文档由一组简单的键值对（字段&#8594;值）组成。一个字段必须包含至少一个值，也可以包含多个值。比如一个字符串可以被分析器分词为多个值。 <em>Lucene</em> 并不关心这些值是 <em>string</em> 或 数值 或日期等类型的，所有的值都被当成 <em>不透明字节</em> 。</p>
</div>
<div class="paragraph">
<p>当我们在 Lucene 中索引一个文档时，每个字段的值都被加到相关字段的倒排索引中。你也可以选择将原始数据 <em>储存</em> 起来以备今后取回。</p>
</div>
</div>
<div class="sect2">
<h3 id="_类型如何实现的"><a class="anchor" href="#_类型如何实现的"></a>55.2. 类型如何实现的</h3>
<div class="paragraph">
<p>在 <em>ES</em> 中，类型这个概念很简单。一个 <em>index</em> 由多个 <em>type</em> 组成，一个 <em>type</em> 又可以包含多个文档。</p>
</div>
<div class="paragraph">
<p>然而在 <em>Lucene</em> 并没有 <em>type</em> 这个概念， <em>ES</em> 在处理时，将文档所属的 <em>type</em> 作为文档的元字段 <code>_type</code> 存储起来，当搜索指定类型的文档时， <em>ES</em> 只是简单地通过 <code>_type</code> 这个元字段来过滤文档即可。</p>
</div>
<div class="paragraph">
<p><em>Lucene</em> 中也没有 <em>mappings</em> 的概念， <em>ES</em> 中使用 <em>Mapping</em> 用来将复杂的 <em>JSON</em> 格式文档映射为 <em>Lucene</em> 中扁平的文档结构。</p>
</div>
</div>
<div class="sect2">
<h3 id="_避免类型陷阱"><a class="anchor" href="#_避免类型陷阱"></a>55.3. 避免类型陷阱</h3>
<div class="paragraph">
<p>当你有两个不同的类型，但是两个类型下都有同样名称的一个字段，不过这两个字段虽然名称相同，但是一个是 string ，一个是 date 类型。</p>
</div>
<div class="paragraph">
<p>当这种情况下时， <em>ES</em> 是不允许你定义这样的 <em>mapping</em> 的，因为 <em>field</em> 名称相同却数据类型不一致。</p>
</div>
<div class="paragraph">
<p>其实这主要的原因是 <em>Lucene</em> 中的索引均为一单个包含所有字段的水平的模式，任何时候一个字段可以是 string ，但是不能又同时是 date 类型。这是因为在 <em>ES</em> 中， <em>type</em> 只是一个在文档中添加一个 <code>_type</code> 的元数据，也就是说同一索引下，任何 <em>type</em> 下都共用一个类型映射。</p>
</div>
<div class="paragraph">
<p>例如，在 <em>ES</em> 中，定义的 mapping 是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">data</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">people</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {
               <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
               },
               <span class="key"><span class="delimiter">&quot;</span><span class="content">address</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
               }
            }
         },
         <span class="key"><span class="delimiter">&quot;</span><span class="content">transactions</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {
               <span class="key"><span class="delimiter">&quot;</span><span class="content">timestamp</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">date</span><span class="delimiter">&quot;</span></span>,
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">format</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">strict_date_optional_time</span><span class="delimiter">&quot;</span></span>
               },
               <span class="key"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>: {
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
               }
            }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是在 <em>Lucene</em> 中，实际的映射可能是这样的。</p>
</div>
<div class="listingblock">
<div class="title">这个不是真正的映射内容，这里只是为了证实 Lucene 中的映射</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">data</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">not_analyzed</span><span class="delimiter">&quot;</span></span>
        },
        <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
        }
        <span class="string"><span class="delimiter">&quot;</span><span class="content">address</span><span class="delimiter">&quot;</span></span>: {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
        }
        <span class="string"><span class="delimiter">&quot;</span><span class="content">timestamp</span><span class="delimiter">&quot;</span></span>: {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">long</span><span class="delimiter">&quot;</span></span>
        }
        <span class="string"><span class="delimiter">&quot;</span><span class="content">message</span><span class="delimiter">&quot;</span></span>: {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>
        }
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也就是说一个索引下的 <em>mappings</em> 都会被扁平化为一单个全局的大的模式。这也就是为什么不同的 <em>type</em> 不能定义有冲突的字段了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_类型逃逸"><a class="anchor" href="#_类型逃逸"></a>55.4. 类型逃逸</h3>
<div class="paragraph">
<p>类型逃逸是什么，严格来说，就是一个索引下多个类型共存时，直到某一天不同类型下的字段冲突了。不过类型在用来区分不同的段时非常有用。</p>
</div>
<div class="paragraph">
<p>类型通常也不会适用于完全不同的类型的数据。如果你在同一索引下，有两个数据类型完成排斥的类型（字段完全不重复），这个时候你的索引将会有一半字段都是空的（想象一下，在 Lucene 中是没有类型的，此时就是一个索引直接对应N个字段），这样会导致一些性能问题的。实际上，碰到这种完成不相干的数据，应该放在不同的索引下面。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_根对象"><a class="anchor" href="#_根对象"></a>56. 根对象</h2>
<div class="sectionbody">
<div class="paragraph">
<p>映射的最高一层被称为 <em>根对象</em>，它可能包含下面几项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个 <em>properties</em> 节点，列出了文档中可能包含的每个字段的映射</p>
</li>
<li>
<p>多个元数据字段，每一个都以下划线开头，例如 <code>_type</code>, <code>_id</code> 和 <code>_source</code></p>
</li>
<li>
<p>设置项，控制如何动态处理新的字段，例如 <code>analyzer</code>, <code>dynamic_date_formats</code> 和 <code>dynamic_templates</code>。</p>
</li>
<li>
<p>其他设置，可以同时应用在根对象和其他 <code>object</code> 类型的字段上，例如 <code>enabled</code>, <code>dynamic</code> 和 <code>include_in_all</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_properties"><a class="anchor" href="#_properties"></a>56.1. properties</h3>
<div class="paragraph">
<p>我们已经在【核心字段】和【复合核心字段】章节中介绍过文档字段和属性的三个最重要的设置：</p>
</div>
<div class="paragraph">
<p><code>type</code>：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>字段的数据类型，例如 `string` 和 `date`</pre>
</div>
</div>
<div class="paragraph">
<p><code>index</code>：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>字段是否应当被当成全文来搜索（`analyzed`），或被当成一个准确的值（`not_analyzed`），还是完全不可被搜索（`no`）</pre>
</div>
</div>
<div class="paragraph">
<p><code>analyzer</code>：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>确定在索引和或搜索时全文字段使用的 `分析器`。</pre>
</div>
</div>
<div class="paragraph">
<p>我们将在下面的章节中介绍其他字段，例如 <code>ip</code>, <code>geo_point</code> 和 <code>geo_shape</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_元数据_source字段"><a class="anchor" href="#_元数据_source字段"></a>56.2. 元数据：_source字段</h3>
<div class="paragraph">
<p>默认情况下，Elasticsearch 用 JSON 字符串来表示文档主体保存在 <code>_source</code> 字段中。像其他保存的字段一样，<code>_source</code> 字段也会在写入硬盘前压缩。</p>
</div>
<div class="paragraph">
<p>这几乎始终是需要的功能，因为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>搜索结果中能得到完整的文档 —— 不需要额外去别的数据源中查询文档</p>
</li>
<li>
<p>如果缺少 <code>_source</code> 字段，部分 <code>更新</code> 请求不会起作用</p>
</li>
<li>
<p>当你的映射有变化，而且你需要重新索引数据时，你可以直接在 Elasticsearch 中操作而不需要重新从别的数据源中取回数据。</p>
</li>
<li>
<p>你可以从 <code>_source</code> 中通过 <code>get</code> 或 <code>search</code> 请求取回部分字段，而不是整个文档。</p>
</li>
<li>
<p>这样更容易排查错误，因为你可以准确的看到每个文档中包含的内容，而不是只能从一堆 ID 中猜测他们的内容。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>即便如此，存储 <code>_source</code> 字段还是要占用硬盘空间的。假如上面的理由对你来说不重要，你可以用下面的映射禁用 <code>_source</code> 字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">my_type</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">enabled</span><span class="delimiter">&quot;</span></span>:  <span class="predefined-constant">false</span>
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以在查询请求中，指定需要返回哪几个字段</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>:   { <span class="key"><span class="delimiter">&quot;</span><span class="content">match_all</span><span class="delimiter">&quot;</span></span>: {}},
    <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: [ <span class="string"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span> ] <img src="./images/icons/callouts/1.png" alt="1">
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>这两个字段会在 <code>_source</code> 字段中提取出来。</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">储存字段</div>
<div class="literalblock">
<div class="content">
<pre>除了索引字段的值，你也可以选择储存字段的原始值以备日后取回。使用 Lucene 做后端的用户用_储存字段_来选择搜索结果的返回值，事实上，_source 字段就是一个储存字段。</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>在 Elasticsearch 中，单独设置储存字段不是一个好做法。完整的文档已经被保存在 _source 字段中。通常最好的办法会是使用 _source 参数来过滤你需要的字段。</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_元数据_all字段"><a class="anchor" href="#_元数据_all字段"></a>56.3. 元数据： _all字段</h3>
<div class="paragraph">
<p>在【简单搜索】中，我们介绍了 <code>_all</code> 字段：一个所有其他字段值的特殊字符串字段。<code>query_string</code> 在没有指定字段时默认用 <code>_all</code> 字段查询。</p>
</div>
<div class="paragraph">
<p><code>_all</code> 字段在新应用的探索阶段比较管用，当你还不清楚最终文档的结构时，可以将任何查询用于这个字段，就有机会得到你想要的文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">GET /_search
{
    &quot;match&quot;: {
        &quot;_all&quot;: &quot;john smith marketing&quot;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>随着你应用的发展，搜索需求会变得更加精准。你会越来越少的使用 <code>_all</code> 字段。<code>_all</code> 是一种简单粗暴的搜索方式。通过查询独立的字段，你能更灵活，强大和精准的控制搜索结果，提高相关性。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>【相关性算法】考虑的一个最重要的原则是字段的长度：字段越短，就越重要。在较短的 <code>title</code> 字段中的短语会比较长的 <code>content</code> 字段中的短语显得更重要。而字段间的这种差异在 <code>_all</code> 字段中就不会出现</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果你决定不再使用 <code>_all</code> 字段，你可以通过下面的映射禁用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index/_mapping/my_type
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">my_type</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_all</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">enabled</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span> }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>include_in_all</code> 选项可以控制字段是否要被包含在 <code>_all</code> 字段中，默认值是 <code>true</code>。在一个对象上设置 <code>include_in_all</code> 可以修改这个对象所有字段的默认行为。</p>
</div>
<div class="paragraph">
<p>你可能想要保留 <code>_all</code> 字段来查询所有特定的全文字段，例如 <code>title</code>, <code>overview</code>, <code>summary</code> 和 <code>tags</code>。相对于完全禁用 <code>_all</code> 字段，你可以先默认禁用 <code>include_in_all</code> 选项，而选定字段上启用 <code>include_in_all</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index/my_type/_mapping
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">my_type</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">include_in_all</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>: {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:           <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
                <span class="key"><span class="delimiter">&quot;</span><span class="content">include_in_all</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">true</span>
            },
            ...
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>谨记 <code>_all</code> 字段仅仅是一个经过分析的 <code>string</code> 字段。它使用默认的分析器来分析它的值，而不管这值本来所在的字段指定的分析器。而且像所有 <code>string</code> 类型字段一样，你可以配置 <code>_all</code> 字段使用的分析器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index/my_type/_mapping
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">my_type</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_all</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">analyzer</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">whitespace</span><span class="delimiter">&quot;</span></span> }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_元数据_文档唯一性"><a class="anchor" href="#_元数据_文档唯一性"></a>56.4. 元数据：文档唯一性</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">_id</dt>
<dd>
<p>文档的ID</p>
</dd>
<dt class="hdlist1">_type</dt>
<dd>
<p>文档的类型</p>
</dd>
<dt class="hdlist1">_index</dt>
<dd>
<p>文档所属的索引</p>
</dd>
<dt class="hdlist1">_uid</dt>
<dd>
<p><code>_type`与 `_id</code> 联合在一起，格式为 type#id</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>默认情况下， <code>_uid</code> 是被存储了（可以被 retrieve 出来）和被索引了（可以被检索）。而 <code>_type</code> 是被索引了但是没有被存储， <code>_id</code> 和 <code>_index</code> 既没有索引也没存储，这意味着这些并不真正存在。</p>
</div>
<div class="paragraph">
<p>尽管如此，你仍然可以像真实字段一样查询 <code>_id</code> 字段。Elasticsearch 使用 <code>_uid</code> 字段来追溯 <code>_id</code>。虽然你可以修改这些字段的 <code>index</code> 和 <code>store</code> 设置，但是基本上不需要这么做。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_动态映射"><a class="anchor" href="#_动态映射"></a>57. 动态映射</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当 Elasticsearch 遭遇一个位置的字段时，它通过【动态映射】来确定字段的数据类型且自动将该字段加到类型映射中。</p>
</div>
<div class="paragraph">
<p>有时这是理想的行为，有时却不是。或许你不知道今后会有哪些字段加到文档中，但是你希望它们能自动被索引。或许你仅仅想忽略它们。特别是当你使用 Elasticsearch 作为主数据源时，你希望未知字段能抛出一个异常来警示你。</p>
</div>
<div class="paragraph">
<p>幸运的是，你可以通过 <code>dynamic</code> 设置来控制这些行为，它接受下面几个选项：</p>
</div>
<div class="paragraph">
<p><code>true</code>：自动添加字段（默认）</p>
</div>
<div class="paragraph">
<p><code>false</code>：忽略字段</p>
</div>
<div class="paragraph">
<p><code>strict</code>：当遇到未知字段时抛出异常</p>
</div>
<div class="paragraph">
<p><code>dynamic</code> 设置可以用在根对象或任何 <code>object</code> 对象上。你可以将 <code>dynamic</code> 默认设置为 <code>strict</code>，而在特定内部对象上启用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">my_type</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">dynamic</span><span class="delimiter">&quot;</span></span>:      <span class="string"><span class="delimiter">&quot;</span><span class="content">strict</span><span class="delimiter">&quot;</span></span>, <img src="./images/icons/callouts/1.png" alt="1">
            <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:  { <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>},
                <span class="key"><span class="delimiter">&quot;</span><span class="content">stash</span><span class="delimiter">&quot;</span></span>:  {
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">object</span><span class="delimiter">&quot;</span></span>,
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">dynamic</span><span class="delimiter">&quot;</span></span>:  <span class="predefined-constant">true</span> <img src="./images/icons/callouts/2.png" alt="2">
                }
          }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>当遇到未知字段时，<code>my_type</code> 对象将会抛出异常</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td><code>stash</code> 对象会自动创建字段
通过这个映射，你可以添加一个新的可搜索字段到 <code>stash</code> 对象中：</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index/my_type/<span class="integer">1</span>
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:   <span class="string"><span class="delimiter">&quot;</span><span class="content">This doc adds a new field</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">stash</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">new_field</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Success!</span><span class="delimiter">&quot;</span></span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是在顶层做同样的操作则会失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index/my_type/<span class="integer">1</span>
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">This throws a StrictDynamicMappingException</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">new_field</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Fail!</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>备注：将 <code>dynamic</code> 设置成 <code>false</code> 完全不会修改 <code>_source</code> 字段的内容。<code>_source</code> 将仍旧保持你索引时的完整 JSON 文档。然而，没有被添加到映射的未知字段将不可被搜索。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_自定义动态映射"><a class="anchor" href="#_自定义动态映射"></a>58. 自定义动态映射</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果你想在运行时的增加新的字段，你可能会开启动态索引。虽然有时动态映射的 <code>规则</code> 显得不那么智能，幸运的是我们可以通过设置来自定义这些规则。</p>
</div>
<div class="sect2">
<h3 id="_日期检测"><a class="anchor" href="#_日期检测"></a>58.1. 日期检测</h3>
<div class="paragraph">
<p>当 Elasticsearch 遇到一个新的字符串字段时，它会检测这个字段是否包含一个可识别的日期，比如 <code>2014-01-01</code>。如果它看起来像一个日期，这个字段会被作为 <code>date</code> 类型添加，否则，它会被作为 <code>string</code> 类型添加。</p>
</div>
<div class="paragraph">
<p>有些时候这个规则可能导致一些问题。想象你有一个文档长这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">note</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-01-01</span><span class="delimiter">&quot;</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设这是第一次见到 <code>note</code> 字段，它会被添加为 <code>date</code> 字段，但是如果下一个文档像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">note</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Logged out</span><span class="delimiter">&quot;</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>这显然不是一个日期，但为时已晚。这个字段已经被添加为日期类型，这个 <code>不合法的日期</code> 将引发异常。</p>
</div>
<div class="paragraph">
<p>日期检测可以通过在根对象上设置 <code>date_detection</code> 为 <code>false</code> 来关闭：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">my_type</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">date_detection</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用这个映射，字符串将始终是 <code>string</code> 类型。假如你需要一个 <code>date</code> 字段，你得手动添加它。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>Elasticsearch 判断字符串为日期的规则可以通过  <a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-root-object-type.html"><code>dynamic_date_formats</code> 配置</a> 来修改。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_动态模板"><a class="anchor" href="#_动态模板"></a>58.2. 动态模板</h3>
<div class="paragraph">
<p>使用 <code>dynamic_templates</code>，你可以完全控制新字段的映射，你设置可以通过字段名或数据类型应用一个完全不同的映射。</p>
</div>
<div class="paragraph">
<p>每个模板都有一个名字用于描述这个模板的用途，一个 <code>mapping</code> 字段用于指明这个映射怎么使用，和至少一个参数（例如 <code>match</code>）来定义这个模板适用于哪个字段。</p>
</div>
<div class="paragraph">
<p>模板按照顺序来检测，第一个匹配的模板会被启用。例如，我们给 <code>string</code> 类型字段定义两个模板：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>es</code>: 字段名以 <code>_es</code> 结尾需要使用 <code>spanish</code> 分析器。</p>
</li>
<li>
<p><code>en</code>: 所有其他字段使用 <code>english</code> 分析器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们将 <code>es</code> 模板放在第一位，因为它比匹配所有字符串的 <code>en</code> 模板更特殊一点</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">my_type</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">dynamic_templates</span><span class="delimiter">&quot;</span></span>: [
                { <span class="key"><span class="delimiter">&quot;</span><span class="content">es</span><span class="delimiter">&quot;</span></span>: {
                      <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>:              <span class="string"><span class="delimiter">&quot;</span><span class="content">*_es</span><span class="delimiter">&quot;</span></span>, <img src="./images/icons/callouts/1.png" alt="1">
                      <span class="key"><span class="delimiter">&quot;</span><span class="content">match_mapping_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
                      <span class="key"><span class="delimiter">&quot;</span><span class="content">mapping</span><span class="delimiter">&quot;</span></span>: {
                          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:           <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
                          <span class="key"><span class="delimiter">&quot;</span><span class="content">analyzer</span><span class="delimiter">&quot;</span></span>:       <span class="string"><span class="delimiter">&quot;</span><span class="content">spanish</span><span class="delimiter">&quot;</span></span>
                      }
                }},
                { <span class="key"><span class="delimiter">&quot;</span><span class="content">en</span><span class="delimiter">&quot;</span></span>: {
                      <span class="key"><span class="delimiter">&quot;</span><span class="content">match</span><span class="delimiter">&quot;</span></span>:              <span class="string"><span class="delimiter">&quot;</span><span class="content">*</span><span class="delimiter">&quot;</span></span>, <img src="./images/icons/callouts/2.png" alt="2">
                      <span class="key"><span class="delimiter">&quot;</span><span class="content">match_mapping_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
                      <span class="key"><span class="delimiter">&quot;</span><span class="content">mapping</span><span class="delimiter">&quot;</span></span>: {
                          <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:           <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
                          <span class="key"><span class="delimiter">&quot;</span><span class="content">analyzer</span><span class="delimiter">&quot;</span></span>:       <span class="string"><span class="delimiter">&quot;</span><span class="content">english</span><span class="delimiter">&quot;</span></span>
                      }
                }}
            ]
}}}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>匹配 <em>string</em> 字段并且名称以 <code>_es</code> 结尾的</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>匹配所有其它的 <em>string</em> 字段</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>match_mapping_type</code> 允许你限制模板只能使用在特定的类型上，就像由标准动态映射规则检测的一样，（例如 <code>strong</code> 和 <code>long</code>）</p>
</div>
<div class="paragraph">
<p><code>match</code> 参数只匹配字段名，<code>path_match</code> 参数则匹配字段在一个对象中的完整路径，所以 <code>address.*.name</code> 规则将匹配一个这样的字段：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">address</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">city</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">New York</span><span class="delimiter">&quot;</span></span>
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unmatch</code> 和 <code>path_unmatch</code> 规则将用于排除未被匹配的字段。更多选项见 <a href="http://bit.ly/1wdHOzG">根对象参考文档</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_默认映射"><a class="anchor" href="#_默认映射"></a>59. 默认映射</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通常，一个索引中的所有类型具有共享的字段和设置。用 <code>_default_</code> 映射来指定公用设置会更加方便，而不是每次创建新的类型时重复操作。<code>_default</code> 映射像新类型的模板。所有在 <code>_default_</code> 映射 <em>之后</em> 的类型将包含所有的默认设置，除非在自己的类型映射中明确覆盖这些配置。</p>
</div>
<div class="paragraph">
<p>例如，我们可以使用 <code>_default_</code> 映射对所有类型禁用 <code>_all</code> 字段，而只在 <code>blog</code> 字段上开启它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_default_</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_all</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">enabled</span><span class="delimiter">&quot;</span></span>:  <span class="predefined-constant">false</span> }
        },
        <span class="key"><span class="delimiter">&quot;</span><span class="content">blog</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_all</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">enabled</span><span class="delimiter">&quot;</span></span>:  <span class="predefined-constant">true</span>  }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>_default_</code> 映射也是定义索引级别的动态模板的好地方。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_重建索引"><a class="anchor" href="#_重建索引"></a>60. 重建索引</h2>
<div class="sectionbody">
<div class="paragraph">
<p>虽然你可以给索引添加新的类型，或给类型添加新的字段，但是你不能添加新的分析器或修改已有字段。假如你这样做，已被索引的数据会变得不正确而你的搜索也不会正常工作。</p>
</div>
<div class="paragraph">
<p>修改在已存在的数据最简单的方法是重新索引：创建一个新配置好的索引，然后将所有的文档从旧的索引复制到新的上。</p>
</div>
<div class="paragraph">
<p><code>_source</code> 字段的一个最大的好处是你已经在 Elasticsearch 中有了完整的文档，你不再需要从数据库中重建你的索引，这样通常会比较慢。</p>
</div>
<div class="paragraph">
<p>为了更高效的索引旧索引中的文档，使用【scan-scoll】来批量读取旧索引的文档，然后将通过【bulk API】来将它们推送给新的索引。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">批量重新索引</div>
<div class="paragraph">
<p>你可以在同一时间执行多个重新索引的任务，但是你显然不愿意它们的结果有重叠。所以，可以将重建大索引的任务通过日期或时间戳字段拆分成较小的任务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="asciidoc">GET /old_index/_search?search_type=scan&amp;scroll=1m
{
    &quot;query&quot;: {
        &quot;range&quot;: {
            &quot;date&quot;: {
                &quot;gte&quot;:  &quot;2014-01-01&quot;,
                &quot;lt&quot;:   &quot;2014-02-01&quot;
            }
        }
    },
    &quot;size&quot;:  1000
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假如你继续在旧索引上做修改，你可能想确保新增的文档被加到了新的索引中。这可以通过重新运行重建索引程序来完成，但是记得只要过滤出上次执行后新增的文档就行了。</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>从 <em>ES</em> V2.3.0 开始，可以使用 <em>Reindex API</em> 来重建索引，不再需要额外的工具。不过该 <em>API</em> 还在试验阶段。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_索引别名"><a class="anchor" href="#_索引别名"></a>61. 索引别名</h2>
<div class="sectionbody">
<div class="paragraph">
<p>前面提到的重新索引过程中的问题是必须更新你的应用，来使用另一个索引名。索引别名正是用来解决这个问题的！</p>
</div>
<div class="paragraph">
<p>索引 <em>别名</em> 就像一个快捷方式或软连接，可以指向一个或多个索引，也可以给任何需要索引名的 API 使用。别名带给我们极大的灵活性，允许我们做到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在一个运行的集群上无缝的从一个索引切换到另一个</p>
</li>
<li>
<p>给多个索引分类（例如，<code>last_three_months</code>）</p>
</li>
<li>
<p>给索引的一个子集创建 <code>视图</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们以后会讨论更多别名的使用场景。现在我们将介绍用它们怎么在零停机时间内从旧的索引切换到新的索引。</p>
</div>
<div class="paragraph">
<p>这里有两种管理别名的途径：<code>_alias</code> 用于单个操作，<code>_aliases</code> 用于原子化多个操作。</p>
</div>
<div class="paragraph">
<p>在这一章中，我们假设你的应用采用一个叫 <code>my_index</code> 的索引。而事实上，<code>my_index</code> 是一个指向当前真实索引的别名。真实的索引名将包含一个版本号：<code>my_index_v1</code>, <code>my_index_v2</code> 等等。</p>
</div>
<div class="paragraph">
<p>开始，我们创建一个索引 <code>my_index_v1</code>，然后将别名 <code>my_index</code> 指向它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index_v1 <img src="./images/icons/callouts/1.png" alt="1">
PUT /my_index_v1/_alias/my_index <img src="./images/icons/callouts/2.png" alt="2"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>创建索引 <code>my_index_v1</code>。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>将别名 <code>my_index</code> 指向 <code>my_index_v1</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>或哪些别名指向这个索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_index_v1/_alias<span class="comment">/*</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>两者都将返回下列值：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">my_index_v1</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">aliases</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">my_index</span><span class="delimiter">&quot;</span></span> : { }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，我们决定修改索引中一个字段的映射。当然我们不能修改现存的映射，索引我们需要重新索引数据。首先，我们创建有新的映射的索引 <code>my_index_v2</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index_v2
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">my_type</span><span class="delimiter">&quot;</span></span>: {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span>: {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span>: {
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>:   <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>:  <span class="string"><span class="delimiter">&quot;</span><span class="content">not_analyzed</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们从将数据从 <code>my_index_v1</code> 迁移到 <code>my_index_v2</code>，下面的过程在【重新索引】中描述过了。一旦我们认为数据已经被正确的索引了，我们就将别名指向新的索引。</p>
</div>
<div class="paragraph">
<p>别名可以指向多个索引，所以我们需要在新索引中添加别名的同时从旧索引中删除它。这个操作需要原子化，所以我们需要用 <code>_aliases</code> 操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /_aliases
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">actions</span><span class="delimiter">&quot;</span></span>: [
        { <span class="key"><span class="delimiter">&quot;</span><span class="content">remove</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">my_index_v1</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">alias</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">my_index</span><span class="delimiter">&quot;</span></span> }},
        { <span class="key"><span class="delimiter">&quot;</span><span class="content">add</span><span class="delimiter">&quot;</span></span>:    { <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">my_index_v2</span><span class="delimiter">&quot;</span></span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">alias</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">my_index</span><span class="delimiter">&quot;</span></span> }}
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样，你的应用就从旧索引迁移到了新的，而没有停机时间。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>即使你认为现在的索引设计已经是完美的了，当你的应用在生产环境使用时，还是有可能在今后有一些改变的。</p>
</div>
<div class="paragraph">
<p>所以请做好准备：在应用中使用别名而不是索引。然后你就可以在任何时候重建索引。别名的开销很小，应当广泛使用。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<h1 id="_深入理解分片" class="sect0"><a class="anchor" href="#_深入理解分片"></a>深入理解分片</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>在 <a href="#Life Inside a Cluster">[Life Inside a Cluster]</a> 中，我们介绍了分片，也说过分片是一个较底层的工作单元。但是分片到底是如何工作的呢？</p>
</div>
<div class="paragraph">
<p>本章主要解决以下问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为什么搜索是 <strong>近</strong> 实时的？</p>
</li>
<li>
<p>为什么文档的 CRUD 操作是近实时的？</p>
</li>
<li>
<p><em>ES</em> 是如何保证你所做的更改操作持久化的，而且在宕机情况下这些更改操作都不会丢失。</p>
</li>
<li>
<p>为什么删除操作并不会立即清除磁盘空间。</p>
</li>
<li>
<p><code>refresh</code> 、<code>flush</code> 、 <code>optimize</code> 这些 <em>API</em> 操作都是干嘛的，你又何时需要用呢?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面，将讲解如何会出现这些问题，并且又是如何解决这些问题的。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使文本可搜索"><a class="anchor" href="#_使文本可搜索"></a>62. 使文本可搜索</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 <em>ES</em> 中首先需要解决的是使文本可以被搜索。在传统数据中，每一个字段存储一个值，但是这并不适合全文搜索。如果说在一个字段的文本值的每一个词或字都需要可搜索的话，那么意味着这个字段需要对应多个值。</p>
</div>
<div class="paragraph">
<p>这种一个字段多个值的需求，正是 <em>倒排索引</em> 需要解决的问题。倒排索引以字对应文档的形式存储。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">Term  | Doc <span class="integer">1</span> | Doc <span class="integer">2</span> | Doc <span class="integer">3</span> | ...
------------------------------------
brown |   X   |       |  X    | ...
fox   |   X   |   X   |  X    | ...
quick |   X   |   X   |       | ...
the   |   X   |       |  X    | ...</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p><em>ES</em> 中每一个被索引的字段，都有其对应的倒排索引。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>倒排索引存储了比包含了一个特定term的文档列表多地多的信息。它可能存储包含每个term的文档数量，一个term出现在指定文档中的频次，每个文档中term的顺序，每个文档的长度，所有文档的平均长度，等等。这些统计信息让Elasticsearch知道哪些term更重要，哪些文档更重要，也就是相关性。</p>
</div>
<div class="paragraph">
<p>需要意识到，为了实现倒排索引预期的功能，它必须要知道集合中所有的文档。</p>
</div>
<div class="paragraph">
<p>在全文检索的早些时候，会为整个文档集合建立一个大索引，并且写入磁盘。只有新的索引准备好了，它就会替代旧的索引，最近的修改才可以被检索。意思就是你哪怕做了一个小的更改（添加了一个文档），就必须重新准备一个新的大索引用来替代旧的索引。</p>
</div>
<div class="sect2">
<h3 id="_不可变性"><a class="anchor" href="#_不可变性"></a>62.1. 不可变性</h3>
<div class="paragraph">
<p>倒排索引写入到磁盘中后就是不可变的。这种不可变性有以下几大好处：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>这个时候不需要锁，因为你压根就不能修改倒排索引，所以自然就不存在会有多个线程并发修改了。</p>
</li>
<li>
<p>一旦索引被读入文件系统的缓存（物理内存，可自行百度Linux文件系统缓存），它就一直在那儿，因为不会改变。只要文件系统缓存有足够的空间，大部分的读会直接访问内存而不是磁盘。这有助于性能提升。</p>
</li>
<li>
<p>在索引的声明周期内，所有的其他缓存（比如过滤查询的缓存）都可用。它们不需要在每次数据变化了都重建，因为数据不会变。</p>
</li>
<li>
<p>写入单个大的倒排索引，可以压缩数据，减少磁盘IO和需要缓存索引的内存大小。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当然，不可变的索引有它的缺点，首先是它不可变！你不能改变它。如果想要搜索一个新文档，必须重建整个索引。这不仅严重限制了一个索引所能装下的数据，还限制了一个索引可以被更新的频次。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_动态更新索引"><a class="anchor" href="#_动态更新索引"></a>63. 动态更新索引</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上面提到了倒排索引的不可变性，这也就意味着新添加一个文档就需要重建整个倒排索引。</p>
</div>
<div class="paragraph">
<p>如何在即保持倒排索引的不可变性的好处，又能更新倒排索引呢？答案就是使用多个倒排索引。</p>
</div>
<div class="paragraph">
<p>相比每次做了一点修改就去重建整个倒排索引，我们可以额外增加倒排索引来反映近期的修改变化。然后查询的时候按照顺序查询，从最老的倒排索引到最新的倒排索引依次进行查询，然后把结果合并（新的覆盖旧的结果）。</p>
</div>
<div class="paragraph">
<p>在 <em>Lucene</em> 中，提出了一个概念 “ <em>per-segment search</em> ” ，每一个段（物理文件）都是一个倒排索引，而且在 <em>Lucene</em> 中 <strong><em>index</em></strong> 这个词用来表示 <strong>一组段</strong> 加 <strong>一个提交点</strong> 。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Index与Shard</div>
<div class="paragraph">
<p>我们在 <em>ES</em> 中称呼的 <strong><em>Shard</em> 就是 <em>Lucene</em> 中的 <em>index</em></strong> 。而 <em>ES</em> 中的 <em>index</em> 则是一组 <em>Shard</em> 的集合。</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>提交点是一个记录所有已知段的文件</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_1101.png" alt="elas 1101">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_1102.png" alt="elas 1102">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_1103.png" alt="elas 1103">
</div>
</div>
<div class="paragraph">
<p>上面整个过程，即 <em>per-segment search</em></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>新文档首先进入索引缓冲区</p>
</li>
<li>
<p>不时，缓冲区内容提交</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>一个新段（倒排索引），写入到了硬盘</p>
</li>
<li>
<p>新的段名称记录到提交点中，提交点内容更新到硬盘</p>
</li>
<li>
<p>硬盘确保是 fsync’ed （  <a href="http://blog.csdn.net/cywosp/article/details/8767327">fsync</a> ），即保存文件系统缓存中的内容全部写入到了硬盘，物理写入。</p>
</li>
</ol>
</div>
</li>
<li>
<p>刚添加的新段被打开（文件打开），并使其中的文档可以被搜索</p>
</li>
<li>
<p>内存中的索引缓冲区被清空，等待新的修改进入</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当查询请求到达分片上时，其下的所有段都依次按新老顺序查询。这种情况下，添加新的文档就比较简单了。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_删除与更新"><a class="anchor" href="#_删除与更新"></a>64. 删除与更新</h2>
<div class="sectionbody">
<div class="paragraph">
<p>因为段（倒排索引）是不可变的，所以也就是旧的文档不能从段中删除。每一个提交点都包含一个 <strong>.del</strong> 文件，这个文件用来记录段上的哪些文档已经被删除了。</p>
</div>
<div class="paragraph">
<p>当一个文档被标记为删除时，其实只是在 <em>.del</em> 文件中做了个记录。这时，被标记为删除的文档其实还是被查询匹配到的，只不过在返回查询结果前会将被标记为删除的文档给过滤掉。</p>
</div>
<div class="paragraph">
<p>更新操作也是类似的，当一个文档更新时，旧的文档被标记为删除，然后新的文档被添加到新段中。当然这多个不同版本的文档可能都会被查询匹配到，不过
在返回结果前旧的版本的文档会被过滤掉。</p>
</div>
<div class="paragraph">
<p>在下面的 <a href="#合并段">[合并段]</a> 章节，将介绍被标记为删除的文档如何从文件系统中真正删除。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_近实时搜索"><a class="anchor" href="#_近实时搜索"></a>65. 近实时搜索</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在文档被添加到新段中并可被搜索时，这中间的延迟还是很明显的。尽管可以快到1分钟内就可以搜索了，但是还是不够快。</p>
</div>
<div class="paragraph">
<p>这里主要的瓶颈在于硬盘，即硬盘写性能差了。提交一个新段到硬盘需要 <code>fsync</code> 操作来确保段被真正的物理写入到硬盘了。但是 <code>fsync</code> 操作代价比较高，所以不能每有一个文档写入时就执行 <code>fsync</code> 。</p>
</div>
<div class="paragraph">
<p>在 <em>ES</em> 中，使用文件系统缓存来避免频繁地执行 <code>fsync</code> 操作。文件从索引缓冲区写入到新段中后，新段是先写入到文件系统缓存，稍候再会写入硬盘。不过一但文件在文件系统缓存中时，它就已经可以被打开并可读了，这就意味着这时这个新段就已经可以被搜索了。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_1105.png" alt="elas 1105">
</div>
<div class="title">Figure 12. 已写入新段（在文件系统缓存中），此时未提交，但是已经可以搜索了。</div>
</div>
<div class="paragraph">
<p><em>Lucene</em> 允许在未执行一个完整的段提交时，新段在文件系统中就可以被打开并搜索。</p>
</div>
<div class="sect2">
<h3 id="_refresh_api"><a class="anchor" href="#_refresh_api"></a>65.1. refresh API</h3>
<div class="paragraph">
<p>在 <em>ES</em> 中，上面提到的这个 <strong>写及打开新段使可搜索</strong> 的操作称为 <em>refresh</em> 。默认情况下，每一个分片都是默认 <em>1s</em> 刷新一次。就也就是上面说的 <em>ES</em> 是近实时搜索了，文档写入后并不会立即可以被搜索，但是 <em>1s</em> 内就可以了。</p>
</div>
<div class="paragraph">
<p>上面自动刷新的操作，可以通过 <em>refresh api</em> 手动执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /_refresh  <img src="./images/icons/callouts/1.png" alt="1">
POST /blogs/_refresh <img src="./images/icons/callouts/2.png" alt="2"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>刷新所有索引</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>只刷新 <em>blogs</em> 索引</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>尽管 <em>refresh</em> 操作比起 <strong>提交段</strong> （指写新的提交点，段物理写入硬盘） 操作要耗费性能小得多。 如果你在生产系统下，频繁地写时你又每隔 <em>1s</em> 刷新的话，还是会浪费不少的性能。此时如果并不那么严格要求立即可搜索的话，可以将 <em>refresh</em> 的间隔时间调大一些。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过指定 <code>refresh_interval</code> 来设置刷新频率。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_logs
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">settings</span><span class="delimiter">&quot;</span></span>: {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">refresh_interval</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">30s</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/1.png" alt="1">
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>设置该索引每隔30s刷新一次</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>refresh_interval</code> 可以在一个已经运行的索引上动态更新。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_logs/_settings
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">refresh_interval</span><span class="delimiter">&quot;</span></span>: -<span class="integer">1</span> } <img src="./images/icons/callouts/1.png" alt="1">

PUT /my_logs/_settings
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">refresh_interval</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">1s</span><span class="delimiter">&quot;</span></span> } <img src="./images/icons/callouts/2.png" alt="2"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>禁用刷新。通过全量写数据或迁移数据时使用。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>设置为1s刷新。</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<img src="./images/icons/caution.png" alt="Caution">
</td>
<td class="content">
<div class="paragraph">
<p>这里设置的 <code>refresh_interval</code> 都最好把单位带上，如 <code>1s</code> 或 <code>1m</code> 。如果不指定单位的话，默认单位为 <code>ms</code> ，如果你设置个1ms的话，那么你的集群在频繁写数据时绝对会跪了。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_使数据持久化"><a class="anchor" href="#_使数据持久化"></a>66. 使数据持久化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果说没有每次执行 <code>fsync</code> 操作来确保将数据完全写入硬盘的话，那么当系统断电时，那些在文件系统缓存（实际为物理内存）中的数据可能会丢失。</p>
</div>
<div class="paragraph">
<p>我们说过一次全提交同步段到磁盘，写提交点，这会列出所有的已知的段。在重启，或重新打开索引时，ES使用这次提交点决定哪些段属于当前的分片。</p>
</div>
<div class="paragraph">
<p>当我们通过每秒的刷新获得近实时的搜索，我们依然需要定时地执行全提交确保能从失败中恢复。但是提交之间的文档怎么办？我们也不想丢失它们。</p>
</div>
<div class="paragraph">
<p>ES增加了事务日志（translog），来记录每次操作。有了事务日志，过程现在如下：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当一个文档被索引，它被加入到内存缓存，同时加到事务日志。</p>
<div class="imageblock">
<div class="content">
<img src="images/elas_1106.png" alt="elas 1106">
</div>
</div>
</li>
<li>
<p>refresh使得分片的进入如下图描述的状态。每秒分片都进行refeash：</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>内存缓冲区的文档写入到段中，但没有fsync。</p>
</li>
<li>
<p>段被打开，使得新的文档可以搜索。</p>
</li>
<li>
<p>缓存被清除</p>
<div class="imageblock">
<div class="content">
<img src="images/elas_1107.png" alt="elas 1107">
</div>
<div class="title">Figure 13. 经过刷新后，索引缓存被清空了，但是事务日志没有被清除</div>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>随着更多的文档加入到缓存区，写入日志，这个过程会继续</p>
<div class="imageblock">
<div class="content">
<img src="images/elas_1108.png" alt="elas 1108">
</div>
</div>
</li>
<li>
<p>不时地，比如日志很大了，新的日志会创建，会进行一次段提交（写盘）</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>内存缓存区的所有文档会写入到新段中。</p>
</li>
<li>
<p>清除缓存</p>
</li>
<li>
<p>一个提交点写入硬盘</p>
</li>
<li>
<p>文件系统缓存通过fsync操作flush到硬盘</p>
</li>
<li>
<p>事务日志被清除</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>事务日志记录了没有flush到硬盘的所有操作。当故障重启后，ES会用最近一次提交点从硬盘恢复所有已知的段，并且从日志里恢复所有的操作。</p>
</div>
<div class="paragraph">
<p>事务日志还用来提供实时的CRUD操作。当你尝试用ID进行CRUD时，它在检索相关段内的文档前会首先检查日志最新的改动。这意味着ES可以实时地获取文档的最新版本。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/elas_1109.png" alt="elas 1109">
</div>
<div class="title">Figure 14. flush过后，段被全提交，事务日志清除</div>
</div>
<div class="sect2">
<h3 id="_flush_api"><a class="anchor" href="#_flush_api"></a>66.1. flush api</h3>
<div class="paragraph">
<p>在 <em>ES</em> 中，执行提交段并截断事务日志的操作被称为 <em>flush</em> 。 <strong>分片默认是每隔30分钟 flush 一次</strong> 或者 事务日志太大时 flush 。具体可以看 translog 的文档来控制这个频率。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /blogs/_flush <img src="./images/icons/callouts/1.png" alt="1">

POST /_flush?wait_for_ongoing <img src="./images/icons/callouts/2.png" alt="2"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>flush 索引 blogs</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>flush 所有索引，并且一直等待直到所有索引全部刷新完成</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一般情况下，你不需要自己来手动 <em>flush</em> 。不过，你可以在重启一个节点，或者关闭某个索引时，执行这个操作（不然，节点重启后得读事务日志恢复）。</p>
</div>
<div class="paragraph">
<p>当 <em>ES</em> 恢复节点或重新打开索引时，都会恢复事务日志中记录的操作。所以事务日志越小，这个恢复速度越快。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">translog有多安全？</div>
<div class="paragraph">
<p>使用事务日志的目的是保证所做的操作（修改）不会丢失。</p>
</div>
<div class="paragraph">
<p>写入到文件中的数据，如果没有 <code>fsync</code> 的话，在系统重启后就会丢失。默认情况下，translog是每隔5s <code>fsync`一次，并且在每一次请求（如index,update,delete,bulk）完成后也会执行，并且是在主、备分片上都执行。这也就是说，你做了一个修改操作后，必须要等到事务日志在主备分片上都执行 `fsync</code> 后才会收到响应。</p>
</div>
<div class="paragraph">
<p>在每一个请求执行完后执行一个 `fsync`还是比较耗性能的，尽管在实践后相对来说还是比较小的性能损耗（尤其是 <em>bulk</em> 请求）。</p>
</div>
<div class="paragraph">
<p>但是在一些大容量卷中，如果可以容忍有几秒的数据丢失，那么可以设置 <code>fsync</code> 操作异步执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">PUT /my_index/_settings
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">index.translog.durability</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">async</span><span class="delimiter">&quot;</span></span>,
    <span class="key"><span class="delimiter">&quot;</span><span class="content">index.translog.sync_interval</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">5s</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面这个配置是可以随时动态更新的。如果你决定了使用 <code>async</code> 方式来写事务日志的话，那么你得承担 <code>sync_interval</code> 时间内的数据丢失情况（系统断电等情况时）。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_合并段"><a class="anchor" href="#_合并段"></a>67. 合并段</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过每秒自动刷新创建新的段，用不了多久段的数量就爆炸了。有太多的段是一个问题。每个段消费文件句柄，内存，cpu资源。更重要的是，每次搜索请求都需要依次检查每个段。段越多，查询越慢。</p>
</div>
<div class="paragraph">
<p>ES通过后台合并段解决这个问题。小段被合并成大段，再合并成更大的段。</p>
</div>
<div class="paragraph">
<p>这是旧的文档从文件系统删除的时候。旧的段不会再复制到更大的新段中。</p>
</div>
<div class="paragraph">
<p>这个过程你不必做什么。当你在索引和搜索时ES会自动处理。这个过程如图：两个提交的段和一个未提交的段合并为了一个更大的段所示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>索引过程中，refresh会创建新的段，并打开它。</p>
</li>
<li>
<p>合并过程会在后台选择一些小的段合并成大的段，这个过程不会中断索引和搜索。</p>
<div class="imageblock">
<div class="content">
<img src="images/elas_1110.png" alt="elas 1110">
</div>
<div class="title">Figure 15. 两个提交的段和一个未提交的段合并为了一个更大的段</div>
</div>
</li>
<li>
<p>下图描述了合并后的操作：</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>新的段flush到了硬盘。</p>
</li>
<li>
<p>新的提交点写入新的段，排除旧的段。</p>
</li>
<li>
<p>新的段打开供搜索。</p>
</li>
<li>
<p>旧的段被删除。</p>
<div class="imageblock">
<div class="content">
<img src="images/elas_1111.png" alt="elas 1111">
</div>
<div class="title">Figure 16. 段合并完后，旧的段被删除</div>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>合并大的段会消耗很多IO和CPU，如果不检查会影响到搜素性能。默认情况下，ES会限制合并过程，这样搜索就可以有足够的资源进行。</p>
</div>
<div class="sect2">
<h3 id="_optimize_api"><a class="anchor" href="#_optimize_api"></a>67.1. optimize api</h3>
<div class="paragraph">
<p><em>optimize api</em> 即强制合并，它用于指示一个 <em>shard</em> 将段合并到指定的 max_num_segments (最大段数)。这是为了减少段的数量（通常会减少到1）达到提高搜索性能的目的。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="./images/icons/warning.png" alt="Warning">
</td>
<td class="content">
<div class="paragraph">
<p>不要在动态的索引（正在活跃更新）上使用optimize API。后台的合并处理已经做的很好了，优化命令会阻碍它的工作。不要干涉！</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在特定的环境下，optimize API是有用的。典型的场景是记录日志，这中情况下日志是按照每天，周，月存入索引。旧的索引一般是只可读的，它们是不可能修改的。
这种情况下，把每个索引的段降至1是有效的。搜索过程就会用到更少的资源，性能更好:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /logstash-<span class="integer">2014</span>-<span class="integer">10</span>/_optimize?max_num_segments=<span class="integer">1</span> <img src="./images/icons/callouts/1.png" alt="1"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>把索引中的每个分片下的段都合并成一个段</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<img src="./images/icons/warning.png" alt="Warning">
</td>
<td class="content">
<div class="paragraph">
<p>使用 <em>optimize</em> 触发的合并操作，一点都不会被抑制。它极有可能会将你的节点上的所有 I/O 资源占用完，这也就可能会导致你的集群无响应。
如果你打算使用 <em>optimize</em> ，建议将分片全部移至一个节点然后单独跑。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<h1 id="_结构化查询_2" class="sect0"><a class="anchor" href="#_结构化查询_2"></a>结构化查询</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p><em>结构化搜索</em> 是指查询包含内部结构的数据。日期，时间，和数字都是结构化的：它们有明确的格式给你执行逻辑操作。一般包括比较数字或日期的范围，或确定两个值哪个大。</p>
</div>
<div class="paragraph">
<p>文本也可以被结构化。一包蜡笔有不同的颜色：<code>红色</code>，<code>绿色</code>，<code>蓝色</code>。一篇博客可能被打上 <code>分布式</code> 和 `搜索`的标签。电子商务产品有商品统一代码（UPCs） 或其他有着严格格式的标识。</p>
</div>
<div class="paragraph">
<p>通过结构化搜索，你的查询结果_始终_是 是或非；是否应该属于集合。结构化搜索不关心文档的相关性或分数，它只是简单的包含或排除文档。</p>
</div>
<div class="paragraph">
<p>这必须是有意义的逻辑，一个数字不能比同一个范围中的其他数字 <em>更多</em>。它只能包含在一个范围中 —— 或不在其中。类似的，对于结构化文本，一个值必须相等或不等。这里没有 <em>更匹配</em> 的概念。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_精确值查询"><a class="anchor" href="#_精确值查询"></a>68. 精确值查询</h2>
<div class="sectionbody">
<div class="paragraph">
<p>对于精确值查询，你应该使用过滤查询。过滤查询最重要的在于它非常快。它不会计算相关度评分，而且还会缓存。记住，请尽可能多地使用过滤查询。</p>
</div>
<div class="sect2">
<h3 id="_对数字类型的词查询"><a class="anchor" href="#_对数字类型的词查询"></a>68.1. 对数字类型的词查询</h3>
<div class="paragraph">
<p>首先介绍词查询是因为你会经常使用它，词查询可以处理数字、boolean、日期和文本类型等。</p>
</div>
<div class="paragraph">
<p>首先，添加一些数据，每行数据包含 <code>price</code>　和 <code>productID</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /my_store/products/_bulk
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">10</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">XHDK-A-1293-#fJ3</span><span class="delimiter">&quot;</span></span> }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">20</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">KDKE-B-9947-#kL5</span><span class="delimiter">&quot;</span></span> }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">3</span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">30</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">JODL-X-1937-#pV7</span><span class="delimiter">&quot;</span></span> }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">4</span> }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">30</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">QQPX-R-3956-#aD8</span><span class="delimiter">&quot;</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们希望根据指定的 <code>price</code> 来查找所有等于该 <code>price</code> 的文档，如果用 <code>SQL</code> 表示的话，就是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">select</span> documents
<span class="keyword">from</span>   products
<span class="keyword">where</span>
  price = <span class="integer">20</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <em>ES Query DSL</em> 中，可以使用 <em>term query</em> 来达到相同的目的。 <em>term query</em> 用于查找精确的词，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">20</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的这种情况下，我们只需要精确匹配到值就行了，并不关心匹配到的文档与词之前的匹配度。此时我们可以使用过滤查询，例如使用 <code>constant-score</code> 查询（不计匹配度的查询）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_store/_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>:{
        <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span>:{  <img src="./images/icons/callouts/1.png" alt="1">
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span>:{
                <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>:{<span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span>:<span class="integer">20</span>} <img src="./images/icons/callouts/2.png" alt="2">
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>使用 <code>constant_score</code> 进入过滤查询模式</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>词查询</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>响应结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span>: [
         {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_index</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">my_store</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">products</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span>, <img src="./images/icons/callouts/1.png" alt="1">
            <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
               <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span>: <span class="integer">20</span>,
               <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">KDKE-B-9947-#kL5</span><span class="delimiter">&quot;</span></span>
            }
         }
      ]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>此处并没有计算评分，由于 <code>constnt_score</code> 所有文档全部使用固定的评分 1　。查询放到 <code>filter</code> 中时将不计算评分。</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_对文本的词查询"><a class="anchor" href="#_对文本的词查询"></a>68.2. 对文本的词查询</h3>
<div class="paragraph">
<p>像我们在开头提到的，<code>term</code> 过滤器可以像匹配数字一样轻松的匹配字符串。让我们通过特定 UPC 标识码来找出产品，而不是通过价格。如果用 SQL 来实现，我们可能会使用下面的查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">SELECT</span> product

<span class="keyword">FROM</span>   products

<span class="keyword">WHERE</span>  productID = <span class="string"><span class="delimiter">&quot;</span><span class="content">XHDK-A-1293-#fJ3</span><span class="delimiter">&quot;</span></span></code></pre>
</div>
</div>
<div class="paragraph">
<p>转到查询 DSL，我们用 <code>term</code> 过滤器来构造一个类似的查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json"><span class="error">G</span><span class="error">E</span><span class="error">T</span> <span class="error">/</span><span class="error">m</span><span class="error">y</span><span class="error">_</span><span class="error">s</span><span class="error">t</span><span class="error">o</span><span class="error">r</span><span class="error">e</span><span class="error">/</span><span class="error">p</span><span class="error">r</span><span class="error">o</span><span class="error">d</span><span class="error">u</span><span class="error">c</span><span class="error">t</span><span class="error">s</span><span class="error">/</span><span class="error">_</span><span class="error">s</span><span class="error">e</span><span class="error">a</span><span class="error">r</span><span class="error">c</span><span class="error">h</span>

{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">filtered</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">XHDK-A-1293-#fJ3</span><span class="delimiter">&quot;</span></span>
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有点出乎意料：我们没有得到任何结果值！为什么呢？问题不在于 <code>term</code> 查询；而在于数据被索引的方式。如果我们使用 <code>analyze</code> API，我们可以看到 UPC 被分解成短小的表征：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json"><span class="error">G</span><span class="error">E</span><span class="error">T</span> <span class="error">/</span><span class="error">m</span><span class="error">y</span><span class="error">_</span><span class="error">s</span><span class="error">t</span><span class="error">o</span><span class="error">r</span><span class="error">e</span><span class="error">/</span><span class="error">_</span><span class="error">a</span><span class="error">n</span><span class="error">a</span><span class="error">l</span><span class="error">y</span><span class="error">z</span><span class="error">e</span><span class="error">?</span><span class="error">f</span><span class="error">i</span><span class="error">e</span><span class="error">l</span><span class="error">d</span><span class="error">=</span><span class="error">p</span><span class="error">r</span><span class="error">o</span><span class="error">d</span><span class="error">u</span><span class="error">c</span><span class="error">t</span><span class="error">I</span><span class="error">D</span>

<span class="error">X</span><span class="error">H</span><span class="error">D</span><span class="error">K</span><span class="error">-</span><span class="error">A</span><span class="integer">-1293</span><span class="error">-</span><span class="error">#</span><span class="error">f</span><span class="error">J</span><span class="integer">3</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{

  <span class="key"><span class="delimiter">&quot;</span><span class="content">tokens</span><span class="delimiter">&quot;</span></span> : [ {

    <span class="key"><span class="delimiter">&quot;</span><span class="content">token</span><span class="delimiter">&quot;</span></span> :        <span class="string"><span class="delimiter">&quot;</span><span class="content">xhdk</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">start_offset</span><span class="delimiter">&quot;</span></span> : <span class="integer">0</span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">end_offset</span><span class="delimiter">&quot;</span></span> :   <span class="integer">4</span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :         <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;ALPHANUM&gt;</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">position</span><span class="delimiter">&quot;</span></span> :     <span class="integer">1</span>

  }, {

    <span class="key"><span class="delimiter">&quot;</span><span class="content">token</span><span class="delimiter">&quot;</span></span> :        <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">start_offset</span><span class="delimiter">&quot;</span></span> : <span class="integer">5</span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">end_offset</span><span class="delimiter">&quot;</span></span> :   <span class="integer">6</span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :         <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;ALPHANUM&gt;</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">position</span><span class="delimiter">&quot;</span></span> :     <span class="integer">2</span>

  }, {

    <span class="key"><span class="delimiter">&quot;</span><span class="content">token</span><span class="delimiter">&quot;</span></span> :        <span class="string"><span class="delimiter">&quot;</span><span class="content">1293</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">start_offset</span><span class="delimiter">&quot;</span></span> : <span class="integer">7</span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">end_offset</span><span class="delimiter">&quot;</span></span> :   <span class="integer">11</span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :         <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;NUM&gt;</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">position</span><span class="delimiter">&quot;</span></span> :     <span class="integer">3</span>

  }, {

    <span class="key"><span class="delimiter">&quot;</span><span class="content">token</span><span class="delimiter">&quot;</span></span> :        <span class="string"><span class="delimiter">&quot;</span><span class="content">fj3</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">start_offset</span><span class="delimiter">&quot;</span></span> : <span class="integer">13</span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">end_offset</span><span class="delimiter">&quot;</span></span> :   <span class="integer">16</span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> :         <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;ALPHANUM&gt;</span><span class="delimiter">&quot;</span></span>,

    <span class="key"><span class="delimiter">&quot;</span><span class="content">position</span><span class="delimiter">&quot;</span></span> :     <span class="integer">4</span>

  } ]

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;!-- SENSE: 080_Structured_Search/05_Term_text.json -&#8594;</p>
</div>
<div class="paragraph">
<p>这里有一些要点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们得到了四个分开的标记，而不是一个完整的标记来表示 UPC。</p>
</li>
<li>
<p>所有的字符都被转为了小写。</p>
</li>
<li>
<p>我们失去了连字符和 <code>#</code> 符号。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所以当我们用 <code>XHDK-A-1293-#fJ3</code> 来查找时，得不到任何结果，因为这个标记不在我们的倒排索引中。相反，那里有上面列出的四个标记。</p>
</div>
<div class="paragraph">
<p>显然，在处理唯一标识码，或其他枚举值时，这不是我们想要的结果。</p>
</div>
<div class="paragraph">
<p>为了避免这种情况发生，我们需要通过设置这个字段为 <code>not_analyzed</code> 来告诉 Elasticsearch 它包含一个准确值。我们曾在【自定义字段映射】中见过它。为了实现目标，我们要先删除旧索引（因为它包含了错误的映射），并创建一个正确映射的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json"><span class="error">D</span><span class="error">E</span><span class="error">L</span><span class="error">E</span><span class="error">T</span><span class="error">E</span> <span class="error">/</span><span class="error">m</span><span class="error">y</span><span class="error">_</span><span class="error">s</span><span class="error">t</span><span class="error">o</span><span class="error">r</span><span class="error">e</span> <img src="./images/icons/callouts/1.png" alt="1">

<span class="error">P</span><span class="error">U</span><span class="error">T</span> <span class="error">/</span><span class="error">m</span><span class="error">y</span><span class="error">_</span><span class="error">s</span><span class="error">t</span><span class="error">o</span><span class="error">r</span><span class="error">e</span> <img src="./images/icons/callouts/2.png" alt="2">

{

    <span class="key"><span class="delimiter">&quot;</span><span class="content">mappings</span><span class="delimiter">&quot;</span></span> : {

        <span class="key"><span class="delimiter">&quot;</span><span class="content">products</span><span class="delimiter">&quot;</span></span> : {

            <span class="key"><span class="delimiter">&quot;</span><span class="content">properties</span><span class="delimiter">&quot;</span></span> : {

                <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : {

                    <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">string</span><span class="delimiter">&quot;</span></span>,

                    <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">not_analyzed</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/3.png" alt="3">

                }

            }

        }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;!-- SENSE: 080_Structured_Search/05_Term_text.json -&#8594;</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>必须首先删除索引，因为我们不能修改已经存在的映射。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>删除后，我们可以用自定义的映射来创建它。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>这里我们明确表示不希望 <code>productID</code> 被分析。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在我们可以继续重新索引文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json"><span class="error">P</span><span class="error">O</span><span class="error">S</span><span class="error">T</span> <span class="error">/</span><span class="error">m</span><span class="error">y</span><span class="error">_</span><span class="error">s</span><span class="error">t</span><span class="error">o</span><span class="error">r</span><span class="error">e</span><span class="error">/</span><span class="error">p</span><span class="error">r</span><span class="error">o</span><span class="error">d</span><span class="error">u</span><span class="error">c</span><span class="error">t</span><span class="error">s</span><span class="error">/</span><span class="error">_</span><span class="error">b</span><span class="error">u</span><span class="error">l</span><span class="error">k</span>

{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">1</span> }}

{ <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">10</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">XHDK-A-1293-#fJ3</span><span class="delimiter">&quot;</span></span> }

{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">2</span> }}

{ <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">20</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">KDKE-B-9947-#kL5</span><span class="delimiter">&quot;</span></span> }

{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">3</span> }}

{ <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">30</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">JODL-X-1937-#pV7</span><span class="delimiter">&quot;</span></span> }

{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="integer">4</span> }}

{ <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">30</span>, <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">QQPX-R-3956-#aD8</span><span class="delimiter">&quot;</span></span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;!-- SENSE: 080_Structured_Search/05_Term_text.json -&#8594;</p>
</div>
<div class="paragraph">
<p>现在我们的 <code>term</code> 过滤器将按预期工作。让我们在新索引的数据上再试一次（注意，查询和过滤都没有修改，只是数据被重新映射了）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json"><span class="error">G</span><span class="error">E</span><span class="error">T</span> <span class="error">/</span><span class="error">m</span><span class="error">y</span><span class="error">_</span><span class="error">s</span><span class="error">t</span><span class="error">o</span><span class="error">r</span><span class="error">e</span><span class="error">/</span><span class="error">p</span><span class="error">r</span><span class="error">o</span><span class="error">d</span><span class="error">u</span><span class="error">c</span><span class="error">t</span><span class="error">s</span><span class="error">/</span><span class="error">_</span><span class="error">s</span><span class="error">e</span><span class="error">a</span><span class="error">r</span><span class="error">c</span><span class="error">h</span>

{

    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {

        <span class="key"><span class="delimiter">&quot;</span><span class="content">filtered</span><span class="delimiter">&quot;</span></span> : {

            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {

                <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {

                    <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">XHDK-A-1293-#fJ3</span><span class="delimiter">&quot;</span></span>

                }

            }

        }

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&lt;!-- SENSE: 080_Structured_Search/05_Term_text.json -&#8594;</p>
</div>
<div class="paragraph">
<p><code>productID</code> 字段没有经过分析，<code>term</code> 过滤器也没有执行分析，所以这条查询找到了准确匹配的值，如期返回了文档 1。</p>
</div>
<div class="sect3">
<h4 id="_内部过滤操作"><a class="anchor" href="#_内部过滤操作"></a>68.2.1. 内部过滤操作</h4>
<div class="paragraph">
<p>Elasticsearch 在内部会通过一些操作来执行一次过滤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>查找匹配文档</em>。</p>
<div class="paragraph">
<p><code>term</code> 过滤器在倒排索引中查找词 <code>XHDK-A-1293-#fJ3</code>，然后返回包含那个词的文档列表。在这个例子中，只有文档 1 有我们想要的词。</p>
</div>
</li>
<li>
<p><em>创建bitset</em></p>
<div class="paragraph">
<p>然后过滤器将创建一个 <strong>bitset</strong>(一个由 1 和 0 组成的数组 —— 描述哪些文档包含这个词)。匹配的文档得到 <code>1</code> 字节，在我们的例子中，字节集将是 <code>[1,0,0,0]</code>，在ES内部，这被表示为 <a href="https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps">roaring map</a>　，它可以有效地 <em>encode</em> 为稀少和密集的 <em>sets</em></p>
</div>
</li>
<li>
<p><em>遍历bitset(s)</em>
每一次query都会产生一个 <em>bitsets</em> ，ES会遍历 <em>bitsets</em> 以便找到那些匹配 <em>filter</em> 的文档。而遍历的顺序则是越稀少的 <em>bitset</em> 越先遍历。（因为它排除了大部分的documents）</p>
</li>
<li>
<p><em>Increment the usage counter</em></p>
<div class="paragraph">
<p><em>ES</em> 会缓存 <em>non-scoring</em> 查询以便快速访问，但是如果那些用的很少的查询都去缓存的话就显得很不明智了。因为倒排索引， <em>Non-scoring</em>　查询本身就已经很快了，所以我们需要缓存那些我们知道会重复使用的查询以免资源浪费。</p>
</div>
<div class="paragraph">
<p>为了办到这一点， <em>ES</em> 会基于每一个索引来做查询记录。如果一个查询在最近的 <em>256</em> 次查询中被使用到了多少，那么它将被缓存在内存中。并且当 <em>bitsets</em> 被缓存后，那些 <em>segments</em> (段)上文档数少于 <em>10000</em> 个的（或者文档数小于该index的总的docs数的3%）将不会缓存。因为这些小的段很快就会消失（被合并成大段），所以小段上去关联 <em>cache</em> 则会造成资源浪费。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>尽管不是非常准确的一个说法，但是你还是尽可能从概念上理解 <em>non-scoring</em> 查询的执行速度比 <em>scoring</em> 查询的速度要快很多，因为它少了最耗时的相关度排序那一步骤。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>尽可能地先考虑使用 <em>non-scoring</em> 查询，再来考虑使用 <em>scoring</em> 查询，这样你可以写出更高效的查询语句。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_组合过滤查询"><a class="anchor" href="#_组合过滤查询"></a>68.3. 组合过滤查询</h3>
<div class="paragraph">
<p>上述两个例子中都是介绍的单个过滤查询的使用，然而在实际使用中，你可能需要过滤多个值或字段。比方说，你如何在 <em>ES</em> 中处理这个 <em>SQL</em> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">SELECT</span> product
<span class="keyword">FROM</span>   products
<span class="keyword">WHERE</span>  (price = <span class="integer">20</span> <span class="keyword">OR</span> productID = <span class="string"><span class="delimiter">&quot;</span><span class="content">XHDK-A-1293-#fJ3</span><span class="delimiter">&quot;</span></span>)
  <span class="keyword">AND</span>  (price != <span class="integer">30</span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况，你需要使用在 constant_score 中嵌套使用 <em>bool</em> 查询，通过 <em>bool</em> 可以连接多个子查询。</p>
</div>
<div class="sect3">
<h4 id="_bool_过滤查询"><a class="anchor" href="#_bool_过滤查询"></a>68.3.1. bool 过滤查询</h4>
<div class="paragraph">
<p><em>bool</em> 查询可以由以下四部分组成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span> :     [],
      <span class="key"><span class="delimiter">&quot;</span><span class="content">should</span><span class="delimiter">&quot;</span></span> :   [],
      <span class="key"><span class="delimiter">&quot;</span><span class="content">must_not</span><span class="delimiter">&quot;</span></span> : [],
      <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span>:    []
   }
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>must</code></dt>
<dd>
<p>该条件下的子句需要 <em>must</em> 匹配，也就是 <em>AND</em></p>
</dd>
<dt class="hdlist1"><code>must_not</code></dt>
<dd>
<p>该条件下的子句 must_not 匹配，也就是 <em>NOT</em></p>
</dd>
<dt class="hdlist1"><code>should</code></dt>
<dd>
<p>至少一个子句匹配，也就是 <em>OR</em></p>
</dd>
<dt class="hdlist1"><code>filter</code></dt>
<dd>
<p>子句必须匹配，但是使用filter模式，也就是 <em>Non-Scoring</em> 查询</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在这次的 <em>bool</em> 查询中，可以忽略它的 <code>filter</code> 子句，因为这里的 <em>bool</em> 查询是嵌套在 <code>constant_score</code> 子句中，即已经是 <em>non-scoring</em> 模式了，所以这里的 <code>filter</code> 子句可以不需要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_store/products/_search
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span> : { <img src="./images/icons/callouts/1.png" alt="1">
         <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : {
              <span class="key"><span class="delimiter">&quot;</span><span class="content">should</span><span class="delimiter">&quot;</span></span> : [
                 { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {<span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">20</span>}}, <img src="./images/icons/callouts/2.png" alt="2">
                 { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {<span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">XHDK-A-1293-#fJ3</span><span class="delimiter">&quot;</span></span>}} <img src="./images/icons/callouts/2.png" alt="2">
              ],
              <span class="key"><span class="delimiter">&quot;</span><span class="content">must_not</span><span class="delimiter">&quot;</span></span> : {
                 <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {<span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">30</span>} <img src="./images/icons/callouts/3.png" alt="3">
              }
           }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>注意，这里还是需要使用 constant_score 查询加 <em>filter</em> 来保证它是 non-scoring 模式。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>这里的两个 <code>term</code> 查询都在 <em>should</em> 从句中，也就是说至少一个 <code>term</code> 需要匹配。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>如何有 <em>product</em> 的 <em>price</em> 为30，则会因为 <code>must_not</code> 从句排除掉。</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>放在 <em>constant-score</em> 模式下的查询都是走的 <em>filter mode</em></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面的查询的返回结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : [
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> :     <span class="integer">10</span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">XHDK-A-1293-#fJ3</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/1.png" alt="1">
        }
    },
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> :     <span class="integer">20</span>, <img src="./images/icons/callouts/2.png" alt="2">
          <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">KDKE-B-9947-#kL5</span><span class="delimiter">&quot;</span></span>
        }
    }
]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>匹配 <code>productID = "XHDK-A-1293-#fJ3"</code> 的词查询</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>匹配 <code>price = 20</code> 的词查询</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_内嵌的boolean查询"><a class="anchor" href="#_内嵌的boolean查询"></a>68.3.2. 内嵌的Boolean查询</h4>
<div class="paragraph">
<p>如果你需要更复杂的查询，可以使用 <em>bool</em> 嵌套查询。</p>
</div>
<div class="paragraph">
<p>例如，如果有以下 <em>SQL</em> 语句示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">SELECT document
FROM   products
WHERE  productID      = <span class="string"><span class="delimiter">&quot;</span><span class="content">KDKE-B-9947-#kL5</span><span class="delimiter">&quot;</span></span>
  OR (     productID = <span class="string"><span class="delimiter">&quot;</span><span class="content">JODL-X-1937-#pV7</span><span class="delimiter">&quot;</span></span>
       AND price     = <span class="integer">30</span> )</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以将它转换为一组内嵌的 <em>bool</em> 过滤查询</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_store/products/_search
{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span> : {
         <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : {
              <span class="key"><span class="delimiter">&quot;</span><span class="content">should</span><span class="delimiter">&quot;</span></span> : [
                { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {<span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">KDKE-B-9947-#kL5</span><span class="delimiter">&quot;</span></span>}}, <img src="./images/icons/callouts/1.png" alt="1">
                { <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : { <img src="./images/icons/callouts/1.png" alt="1">
                  <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span> : [
                    { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {<span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">JODL-X-1937-#pV7</span><span class="delimiter">&quot;</span></span>}}, <img src="./images/icons/callouts/2.png" alt="2">
                    { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : {<span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : <span class="integer">30</span>}} <img src="./images/icons/callouts/2.png" alt="2">
                  ]
                }}
              ]
           }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>这里的 <em>term</em> 查询与 <em>bool</em> 查询是兄弟节点并同属于 <em>should</em> 子句下。这里表示至少其中一个匹配。</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>这里的两个 <em>term</em> 查询同属于 <em>must</em> 子句下，所以是必须匹配。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面的查询示例，结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : [
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> :     <span class="integer">20</span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">KDKE-B-9947-#kL5</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/1.png" alt="1">
        }
    },
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> :      <span class="integer">30</span>, <img src="./images/icons/callouts/2.png" alt="2">
          <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">JODL-X-1937-#pV7</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/2.png" alt="2">
        }
    }
]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td><code>productID</code>　匹配了第一个 <em>bool</em> 中的 <em>term</em> 查询</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>这两个匹配到了内嵌的 <em>bool</em> 查询中的 <em>term</em> 查询</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>这里只是一个简单的例子，但是它证明了 <em>bool</em> 查询是如何组装成复杂的查询的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_多值精确查询_in_查询"><a class="anchor" href="#_多值精确查询_in_查询"></a>68.4. 多值精确查询（IN 查询）</h3>
<div class="paragraph">
<p><code>term</code>　查询适合单值的精确匹配，但是如果要多值做精确匹配呢。</p>
</div>
<div class="paragraph">
<p>此时可以不需要使用多个 <em>term</em> 查询组合，直接使用　<em>terms</em> 查询就可以搞定。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">terms</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : [<span class="integer">20</span>, <span class="integer">30</span>]
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>跟普通的 <code>term</code> 查询一样，我们把 <code>terms</code> 查询放到 <code>constant-score</code> 查询做 <code>Non-Scoring</code> 查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_store/products/_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">terms</span><span class="delimiter">&quot;</span></span> : { <img src="./images/icons/callouts/1.png" alt="1">
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : [<span class="integer">20</span>, <span class="integer">30</span>]
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>同上面的 <em>terms</em> 查询一样，只是放到了 <code>constant-score</code> 中。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上述查询返回结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : [
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :    <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> : <span class="float">1.0</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> :     <span class="integer">20</span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">KDKE-B-9947-#kL5</span><span class="delimiter">&quot;</span></span>
        }
    },
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :    <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> : <span class="float">1.0</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> :     <span class="integer">30</span>,
          <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">JODL-X-1937-#pV7</span><span class="delimiter">&quot;</span></span>
        }
    },
    {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>:     <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span>:  <span class="float">1.0</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span>: {
           <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span>:     <span class="integer">30</span>,
           <span class="key"><span class="delimiter">&quot;</span><span class="content">productID</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">QQPX-R-3956-#aD8</span><span class="delimiter">&quot;</span></span>
        }
     }
]</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_包含_但是不是精确的等于"><a class="anchor" href="#_包含_但是不是精确的等于"></a>68.4.1. 包含，但是不是精确的等于</h4>
<div class="paragraph">
<p>这里需要注意的是， <code>term</code> 与 <code>terms</code> 查询都不是精确的匹配，而是包含。这是什么意思呢？
如果你有一个这样的 <em>term query</em> ： <code>{ "term" : { "tags" : "search" } }</code> ，那么它将匹配下面的两个文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>] }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">open_source</span><span class="delimiter">&quot;</span></span>] } <img src="./images/icons/callouts/1.png" alt="1"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>这个文档也会被返回，尽管它并不是完全匹配 <em>search</em> 的。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>回忆下 <code>term</code> 查询是如何工作的：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>检索出倒排索引中包含该词的所有文档</p>
</li>
<li>
<p>构造出一个 <em>bitset</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>现在我们有如何的一个倒排索引：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DocsID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>open_source</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>search</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code>,<code>2</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>当执行了 <code>search</code> 词查询时，它会通过对应的词找到它在倒排索引中关联的文档ID。如上面所描述的，关联的ＩＤ就是1和2，所以这两个都会被返回。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note">
</td>
<td class="content">
<div class="paragraph">
<p>倒排索引的特性决定了实体属性的相等比较是非常难计算的。你不可能知道某一文档只包含你请求的词，它还可能包含其它的词。如果你要做到这点，你需要根据你请求的词找到匹配的文档，然后再依次遍历匹配的这些文档，看这些文档还有没有其它的词在这个字段上。</p>
</div>
<div class="paragraph">
<p>你可以想象，这种操作是极其低效的。正是因为这个原因，所以 <code>term</code> 和 <code>terms</code> 查询都是包含而非精确的相等。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_精确相等"><a class="anchor" href="#_精确相等"></a>68.4.2. 精确相等</h4>
<div class="paragraph">
<p>如果你一定需要字段值是完全精确相等匹配的话，你可以通过添加一个新的字段来达到这个目的。在这个新的字段中，以你的原字段所包含的词个数作为值存储。</p>
</div>
<div class="paragraph">
<p>在上述的例子中，我们添加新的字段 <strong>tag_count</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>], <span class="key"><span class="delimiter">&quot;</span><span class="content">tag_count</span><span class="delimiter">&quot;</span></span> : <span class="integer">1</span> }
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">open_source</span><span class="delimiter">&quot;</span></span>], <span class="key"><span class="delimiter">&quot;</span><span class="content">tag_count</span><span class="delimiter">&quot;</span></span> : <span class="integer">2</span> }</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时，可以再来多加一个 <strong>tag_count</strong> 作为条件来匹配</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_index/my_type/_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
                 <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span> : {
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span> : [
                        { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span> } }, <img src="./images/icons/callouts/1.png" alt="1">
                        { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">tag_count</span><span class="delimiter">&quot;</span></span> : <span class="integer">1</span> } } <img src="./images/icons/callouts/2.png" alt="2">
                    ]
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>查找所有包含词 <code>search</code> 的文档</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>并且只包含1个词</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在这个匹配就达到了上述所希望的精确匹配了。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ranges_范围查询"><a class="anchor" href="#_ranges_范围查询"></a>68.5. Ranges（范围查询）</h3>
<div class="paragraph">
<p>在本章讨论数字的查询时，我们大多介绍的是数字精确匹配查询。实际应用中，数字范围匹配也用地非常多。例如，你需要查找价格在$20到$40之间的产品。</p>
</div>
<div class="paragraph">
<p>在 <code>SQL</code> 查询中，可能是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">SELECT document
FROM   products
WHERE  price BETWEEN <span class="integer">20</span> AND <span class="integer">40</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Elasticsearch</em> 有一个 <code>Range</code> 查询，毫无疑问，就是用于范围匹配文档的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">range</span><span class="delimiter">&quot;</span></span> : {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">gte</span><span class="delimiter">&quot;</span></span> : <span class="integer">20</span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">lte</span><span class="delimiter">&quot;</span></span> : <span class="integer">40</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Range</code> 查询支持以下几种匹配符：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>gt</code> : <code>&gt;</code> 大于</p>
</li>
<li>
<p><code>lt</code> : <code>&lt;</code> 小于</p>
</li>
<li>
<p><code>gte</code> : <code>&gt;=</code> 大于等于</p>
</li>
<li>
<p><code>lte</code> : <code>&lt;=</code> 小于等于</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>查询示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_store/products/_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">range</span><span class="delimiter">&quot;</span></span> : {
                    <span class="key"><span class="delimiter">&quot;</span><span class="content">price</span><span class="delimiter">&quot;</span></span> : {
                        <span class="key"><span class="delimiter">&quot;</span><span class="content">gte</span><span class="delimiter">&quot;</span></span> : <span class="integer">20</span>,
                        <span class="key"><span class="delimiter">&quot;</span><span class="content">lt</span><span class="delimiter">&quot;</span></span>  : <span class="integer">40</span>
                    }
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_date类型的范围查询"><a class="anchor" href="#_date类型的范围查询"></a>68.5.1. Date类型的范围查询</h4>
<div class="paragraph">
<p><code>Range</code> 查询也可以被用于日期查询上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">range</span><span class="delimiter">&quot;</span></span> : {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">timestamp</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">gt</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-01-01 00:00:00</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">lt</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-01-07 00:00:00</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 <code>Range</code> 查询用于 <code>date</code> 类型的字段上时，可以使用 <em>date math</em> 操作。例如，根据时间戳字段查询最近一小时的文档。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">range</span><span class="delimiter">&quot;</span></span> : {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">timestamp</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">gt</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">now-1h</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>date math</em> 也可以用于具体的某一个日期值上，不过不像与 <em>now</em> 使用一样，它需要使用 <code>||</code> 将日期与 <em>date math</em> 表达式拼接起来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">range</span><span class="delimiter">&quot;</span></span> : {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">timestamp</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">gt</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-01-01 00:00:00</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">lt</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">2014-01-01 00:00:00||+1M</span><span class="delimiter">&quot;</span></span> <img src="./images/icons/callouts/1.png" alt="1">
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>早于（2014-01-01加1个月）</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>查看 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/master/mapping-date-format.html">date format reference documentation</a> 以了解更多关于 <em>date math</em> 相关知识。</p>
</div>
</div>
<div class="sect3">
<h4 id="_字符串上使用range查询"><a class="anchor" href="#_字符串上使用range查询"></a>68.5.2. 字符串上使用Range查询</h4>
<div class="paragraph">
<p><code>Range</code> 查询也可以用在字符串类型字段上，字符串类型的比较则是基于字典顺序或字典顺序进行比较。</p>
</div>
<div class="paragraph">
<p>例如，下面就是根据字典顺序排序。
* 5, 50, 6, B, C, a, ab, abb, abc, b</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip">
</td>
<td class="content">
<div class="paragraph">
<p>倒排索引中的词是按照字段顺序存储的，这也是为什么字符串范围匹配会基于字典顺序。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果需要查询以a开头，但是不包含b，则可以如下查询：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">range</span><span class="delimiter">&quot;</span></span> : {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">title</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">gte</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>,
        <span class="key"><span class="delimiter">&quot;</span><span class="content">lt</span><span class="delimiter">&quot;</span></span> :  <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>
    }
}</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">注意基数大小</div>
<div class="paragraph">
<p>数字与日期类型的存储方式都非常便于范围查询，但是字符串类型则不是这样。</p>
</div>
<div class="paragraph">
<p>要在字符串类型的字段上执行一个范围查询， <em>Elasticsearch</em> 需要执行一个 <code>term</code> 过滤以匹配每一个文档，这通常比数字与日期类型的范围查询慢得多。</p>
</div>
<div class="paragraph">
<p>当字段的基数小时（唯一的词数量较少，重复的词数量大），字符中类型的范围查询也还好。但是该字段上唯一的词越多，字符范围查询效率就越低。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_空值查询"><a class="anchor" href="#_空值查询"></a>68.6. 空值查询</h3>
<div class="paragraph">
<p><strong>如果一个字段没有值，那么它在倒排索引中又是如何存储的呢？</strong></p>
</div>
<div class="paragraph">
<p>这个问题的答案上，根本就不存储。回顾先前的例子中提到的倒排索引：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DocIDs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>open_source</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>search</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1,2</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果这个字段没有值，也就说明它没有词，那你又如何存储在倒排索引上呢？不过有时数据就是这样，有这种空值的情况。</p>
</div>
<div class="paragraph">
<p><em>Elasticsearch</em> 提供了一些空值的查询。</p>
</div>
<div class="sect3">
<h4 id="_exist查询"><a class="anchor" href="#_exist查询"></a>68.6.1. exist查询</h4>
<div class="paragraph">
<p><code>exist</code> 查询，它用于匹配在指定字段下有值的那些文档。</p>
</div>
<div class="paragraph">
<p>准备一些测试数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">POST /my_index/posts/_bulk
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>              }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>]                }  <img src="./images/icons/callouts/1.png" alt="1">
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>              }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">open_source</span><span class="delimiter">&quot;</span></span>] }  <img src="./images/icons/callouts/2.png" alt="2">
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>              }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">other_field</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">some data</span><span class="delimiter">&quot;</span></span>        }  <img src="./images/icons/callouts/3.png" alt="3">
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span>              }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : <span class="predefined-constant">null</span>                      }  <img src="./images/icons/callouts/4.png" alt="4">
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">index</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">5</span><span class="delimiter">&quot;</span></span>              }}
{ <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>]          }  <img src="./images/icons/callouts/5.png" alt="5"></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>tags字段只有1个值</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/2.png" alt="2"></td>
<td>tags字段有2个值</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/3.png" alt="3"></td>
<td>没有tags字段</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/4.png" alt="4"></td>
<td>tags字段显示的设置了一个null</td>
</tr>
<tr>
<td><img src="./images/icons/callouts/5.png" alt="5"></td>
<td>tags字段有1个值和一个null</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最终 <code>tags</code> 字段上的倒排索引将是这样的：</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DocIDs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>open_source</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>search</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1,2,5</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在 <code>SQL</code> 中，可以使用 <code>IS NOT NULL</code> 来查看某字段值存在的数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">SELECT</span> tags
<span class="keyword">FROM</span>   posts
<span class="keyword">WHERE</span>  tags <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="predefined-constant">NULL</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>Elasticsearch</code>　中，将使用 <em>exists</em>　查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_index/posts/_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span> : {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">exists</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">field</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最终将返回 <em>3</em> 个文档。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : [
    {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">1</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>] }
    },
    {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">5</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>] } <img src="./images/icons/callouts/1.png" alt="1">
    },
    {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">2</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : [<span class="string"><span class="delimiter">&quot;</span><span class="content">search</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">open source</span><span class="delimiter">&quot;</span></span>] }
    }
]</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>尽管文档5上的tags字段包含一个null值，但是它还有一个 <code>search</code> 值啊，并且这个 <code>search</code> 是存在倒排索引上的。</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_missing查询"><a class="anchor" href="#_missing查询"></a>68.6.2. missing查询</h4>
<div class="paragraph">
<p><code>missing</code> 查询相当于 <code>exists</code> 查询的反义词。它返回在指定字段上没有值的文档。</p>
</div>
<div class="paragraph">
<p><code>SQL</code> 中的查询是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="sql"><span class="class">SELECT</span> tags
<span class="keyword">FROM</span>   posts
<span class="keyword">WHERE</span>  tags <span class="keyword">IS</span> <span class="predefined-constant">NULL</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Elasticsearch</code> 中的查询是这样的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /my_index/posts/_search
{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span> : {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span> : {
            <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span>: {
                <span class="key"><span class="delimiter">&quot;</span><span class="content">missing</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">field</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>返回结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js"><span class="string"><span class="delimiter">&quot;</span><span class="content">hits</span><span class="delimiter">&quot;</span></span> : [
    {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">3</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">other_field</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">some data</span><span class="delimiter">&quot;</span></span> }
    },
    {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_id</span><span class="delimiter">&quot;</span></span> :     <span class="string"><span class="delimiter">&quot;</span><span class="content">4</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_score</span><span class="delimiter">&quot;</span></span> :  <span class="float">1.0</span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">_source</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">tags</span><span class="delimiter">&quot;</span></span> : <span class="predefined-constant">null</span> }
    }
]</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">什么时候NULL才是NULL</div>
<div class="paragraph">
<p>有时候你需要区分一个字段是真的没值呢还是显式的设置了一个null值。此时可以在 <em>mapping</em> 中指定一个 <code>null_value</code> 值，该值在碰到 <em>null</em> 值时将使用设置的 <code>null_value</code> 替换掉null值。</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_exists_missing_on_objects"><a class="anchor" href="#_exists_missing_on_objects"></a>68.6.3. exists/missing on Objects</h4>
<div class="paragraph">
<p><code>exists</code> 和 <code>missing</code> 查询也可以用在 <code>inner objects</code> 上。</p>
</div>
<div class="paragraph">
<p>例如，有如下一个文档：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> : {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>,
      <span class="key"><span class="delimiter">&quot;</span><span class="content">last</span><span class="delimiter">&quot;</span></span> :  <span class="string"><span class="delimiter">&quot;</span><span class="content">Smith</span><span class="delimiter">&quot;</span></span>
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这时，你可以使用 <code>exists</code> 检查 <code>name.first</code> ， <code>name.last</code> 及 <code>name</code> 是否存在。</p>
</div>
<div class="paragraph">
<p>在《类型与映射》章节提到过，object映射最终会在 <em>lucene</em> 中被扁平化，如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
   <span class="key"><span class="delimiter">&quot;</span><span class="content">name.first</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">John</span><span class="delimiter">&quot;</span></span>,
   <span class="key"><span class="delimiter">&quot;</span><span class="content">name.last</span><span class="delimiter">&quot;</span></span>  : <span class="string"><span class="delimiter">&quot;</span><span class="content">Smith</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此时在 <code>name</code> 是执行 <code>exists</code> 或 <code>missing</code> 查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">exists</span><span class="delimiter">&quot;</span></span> : { <span class="key"><span class="delimiter">&quot;</span><span class="content">field</span><span class="delimiter">&quot;</span></span> : <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span> }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <em>ES</em> 内部，是转换成如下查询的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">{
    <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span>: {
        <span class="key"><span class="delimiter">&quot;</span><span class="content">should</span><span class="delimiter">&quot;</span></span>: [
            { <span class="key"><span class="delimiter">&quot;</span><span class="content">exists</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">field</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">name.first</span><span class="delimiter">&quot;</span></span> }},
            { <span class="key"><span class="delimiter">&quot;</span><span class="content">exists</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">field</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">name.last</span><span class="delimiter">&quot;</span></span> }}
        ]
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_关于缓存"><a class="anchor" href="#_关于缓存"></a>68.7. 关于缓存</h3>
<div class="paragraph">
<p>在先前的《内部过滤操作》中，我们提到过 <code>non-scroing</code> 查询是如何计算的。它的核心是使用 <em>bitset</em> 表示那些哪些文档被 <em>filter</em> 命中。当 <em>Elasticsearch</em> 决定了一个文档将来可能被重用时，它会缓存这个 <em>bitset</em> 。一旦缓存了 <em>bitset</em> ，当同样的查询来时，将重用这些缓存的 <em>bitset</em> 。</p>
</div>
<div class="paragraph">
<p>这些缓存是非常聪明的，它会随着你增加新文档而更新。当你添加了新的文档时，它只需将那些匹配 <em>filter</em> 的新的文档添加到缓存的 <em>bitset</em> 中。</p>
</div>
<div class="sect3">
<h4 id="_独立的查询缓存"><a class="anchor" href="#_独立的查询缓存"></a>68.7.1. 独立的查询缓存</h4>
<div class="paragraph">
<p>一个搜索请求中的每一个查询组件对应的 <em>bitset</em> 都是互相独立的。这也就意味着，一旦一个查询组件对应的 <em>bitset</em> 缓存了，这个查询组件可以用于其它的搜索请求中，查询组件是不依赖于包围它的上下文查询。这些缓存将加速你的所有搜索请求中的某一部分。　<strong>注意，缓存的是搜索请求中的某一个query component</strong></p>
</div>
<div class="paragraph">
<p>同样的，一个搜索请求中某一个查询组件的 <em>bitset</em> 被缓存后，它可以被其它查询组件复用。</p>
</div>
<div class="paragraph">
<p>下面看一个查询示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the inbox and have not been read</p>
</li>
<li>
<p>Not in the inbox but have been marked as important</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="js">GET /inbox/emails/_search
{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">query</span><span class="delimiter">&quot;</span></span>: {
      <span class="key"><span class="delimiter">&quot;</span><span class="content">constant_score</span><span class="delimiter">&quot;</span></span>: {
          <span class="key"><span class="delimiter">&quot;</span><span class="content">filter</span><span class="delimiter">&quot;</span></span>: {
              <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span>: {
                 <span class="key"><span class="delimiter">&quot;</span><span class="content">should</span><span class="delimiter">&quot;</span></span>: [
                    { <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span>: {
                          <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span>: [
                             { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">folder</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">inbox</span><span class="delimiter">&quot;</span></span> }}, <img src="./images/icons/callouts/1.png" alt="1">
                             { <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">read</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">false</span> }}
                          ]
                    }},
                    { <span class="key"><span class="delimiter">&quot;</span><span class="content">bool</span><span class="delimiter">&quot;</span></span>: {
                          <span class="key"><span class="delimiter">&quot;</span><span class="content">must_not</span><span class="delimiter">&quot;</span></span>: {
                             <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">folder</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">inbox</span><span class="delimiter">&quot;</span></span> } <img src="./images/icons/callouts/1.png" alt="1">
                          },
                          <span class="key"><span class="delimiter">&quot;</span><span class="content">must</span><span class="delimiter">&quot;</span></span>: {
                             <span class="key"><span class="delimiter">&quot;</span><span class="content">term</span><span class="delimiter">&quot;</span></span>: { <span class="key"><span class="delimiter">&quot;</span><span class="content">important</span><span class="delimiter">&quot;</span></span>: <span class="predefined-constant">true</span> }
                          }
                    }}
                 ]
              }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><img src="./images/icons/callouts/1.png" alt="1"></td>
<td>这两个查询组件是独立的，但是它们会共用一个 <em>bitset</em></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_自动缓存"><a class="anchor" href="#_自动缓存"></a>68.7.2. 自动缓存</h4>
<div class="paragraph">
<p>在早期的 <em>ES</em> 版本中，默认的行为是缓存所有可以缓存的东西。</p>
</div>
<div class="paragraph">
<p>现在的 <em>ES</em> 版本中，将自动根据查询组件的使用频率来缓存。如果一个 <em>non-scoring</em> 查询在最近的256次查询中出现过多次，那么这个查询将被作为侯选的缓存对象。但是，不是所有的段都会缓存到 <em>bitset</em> 中，只有持有docs数量大于 <em>10000</em> （或该索引总的docs数的3%）才会缓存 <em>bitset</em>　，因为小的段本身是可以被快速检索的而且小的段很快被会合并到大段中，也就是说没必要缓存小的段。</p>
</div>
<div class="paragraph">
<p><em>bitset</em> 一旦被缓存后，它将一直存活直至被驱逐出去。缓存逐出算法是基于 LRU （least recently used） 的，当缓存空间满时，那些最近使用次数最少的缓存对象将会被逐出。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2016-09-22 22:03:34 中国标准时间
</div>
</div>
</body>
</html>