= Holding Your Objects
:imagesDir: images

== Adding groups of elements

[source,java]
----
Collection<Integer> collection = new ArrayList<Integer>(Arrays.asList(1,2,3,4,5)); // <1> <2>

Collections.addAll(collection, 1,2,3,4,5); // <3>
----
<1> 使用构造函数装入其它 _Collection_
<2> _Arrays.asList_ 将数组转为固定数组的集合
<3> _Collections.addAll()_　为集合添加元素

[IMPORTANT]
====
_Arrays.asList()_ 返回的是一个固定长度的数组集合，其继承了AbstractList，其内部维持了一个固定的数组。
由于它没有重写父类的 _add_ 与　_remove_ 方法，所以 _Arrays.asList()_ 返回的 _List_ 调用 _add_ 或 _remove_ 方法将会出现错误。

.见 _Arrays_ 的嵌套类 _ArrayList_
image::ArraysAsList.png[]
====

=== Arrays.asList

[source,java]
----
package holding;//: holding/AsListInference.java
// Arrays.asList() makes its best guess about type.

import java.util.*;

class Snow {
}

class Powder extends Snow {
}

class Light extends Powder {
}

class Heavy extends Powder {
}

class Crusty extends Snow {
}

class Slush extends Snow {
}

public class AsListInference {
    public static void main(String[] args) {
        List<Snow> snow1 = Arrays.asList(
                new Crusty(), new Slush(), new Powder());

        // Won't compile:
        // List<Snow> snow2 = Arrays.asList( // <1>
        //   new Light(), new Heavy());
        // Compiler says:
        // found   : java.util.List<Powder>
        // required: java.util.List<Snow>

        // Collections.addAll() doesn't get confused:
        List<Snow> snow3 = new ArrayList<Snow>();
        Collections.addAll(snow3, new Light(), new Heavy()); // <2>

        // Give a hint using an
        // explicit type argument specification:
        List<Snow> snow4 = Arrays.<Snow>asList( // <3>
                new Light(), new Heavy());

        snow4.add(new Powder()); // <4>
    }
} ///:~
----
<1> 这里不能编译，父类 _Powder_ 不自动向上转型为 _Snow_
<2> 使用 _Collections.addAll()_ 不会存在 (1) 中的问题
<3> 使用 *Arrays.<Snow>asList* 可以强制转型
<4> 这里调用失败，不能给 _Arrays.asList()_ 返回的集合 _add_ 或 _remove_ 元素。

[source,java]
----
Exception in thread "main" java.lang.UnsupportedOperationException
	at java.util.AbstractList.add(AbstractList.java:131)
	at java.util.AbstractList.add(AbstractList.java:91)
	at holding.AsListInference.main(AsListInference.java:45)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
----

== Printing containers
_Array_ 使用 _Arrays.toString()_ 来输入一个可阅读的数组值。
而 _Map_ 或 _List_ 则可以直接输出，因为它们的父类重写了 _toString()_ 。

[source,java]
----
package holding;//: holding/PrintingContainers.java
// Containers print themselves automatically.

import java.util.*;

import static net.mindview.util.Print.*;

public class PrintingContainers {
    static Collection fill(Collection<String> collection) {
        collection.add("rat");
        collection.add("cat");
        collection.add("dog");
        collection.add("dog");
        return collection;
    }

    static Map fill(Map<String, String> map) {
        map.put("rat", "Fuzzy");
        map.put("cat", "Rags");
        map.put("dog", "Bosco");
        map.put("dog", "Spot");
        return map;
    }

    public static void main(String[] args) {
        print(fill(new ArrayList<String>()));
        print(fill(new LinkedList<String>()));
        print(fill(new HashSet<String>()));
        print(fill(new TreeSet<String>()));
        print(fill(new LinkedHashSet<String>()));
        print(fill(new HashMap<String, String>()));
        print(fill(new TreeMap<String, String>()));
        print(fill(new LinkedHashMap<String, String>()));
    }
} /* Output:
[rat, cat, dog, dog]
[rat, cat, dog, dog]
[dog, cat, rat]
[cat, dog, rat]
[rat, cat, dog]
{dog=Spot, cat=Rags, rat=Fuzzy}
{cat=Rags, dog=Spot, rat=Fuzzy}
{rat=Fuzzy, cat=Rags, dog=Spot}
*///:~
----

._AbstractMap_ 中重写了 _toString()_
[source,java]
----
    public String toString() {
	Iterator<Entry<K,V>> i = entrySet().iterator();
	if (! i.hasNext())
	    return "{}";

	StringBuilder sb = new StringBuilder();
	sb.append('{');
	for (;;) {
	    Entry<K,V> e = i.next();
	    K key = e.getKey();
	    V value = e.getValue();
	    sb.append(key   == this ? "(this Map)" : key);
	    sb.append('=');
	    sb.append(value == this ? "(this Map)" : value);
	    if (! i.hasNext())  // <1>
		return sb.append('}').toString();
	    sb.append(", ");
	}
    }
----
<1> 通过前面判断来阻止最后追加 `,`

._AbstractCollection_
[source,java]
----
    public String toString() {
        Iterator<E> i = iterator();
	if (! i.hasNext())
	    return "[]";

	StringBuilder sb = new StringBuilder();
	sb.append('[');
	for (;;) {
	    E e = i.next();
	    sb.append(e == this ? "(this Collection)" : e);
	    if (! i.hasNext())
		return sb.append(']').toString();
	    sb.append(", ");
	}
    }
----

image::Collections.png[]

|===
|名称|说明|
|ArrayList|List，按插入顺序输出。List是不去重复的，基于数组实现。|
|LinkedList|List,按插入顺序输出。保证为插入时的顺序，基于链表实现。|
|HashSet|Set,去重复的，无序，基于Hash查找速度快|
|TreeSet|Set,去重复的，按字母顺序排序|
|LinkedHashSet|Set,去重复的，保证为插入时的顺序，基于链表实现|
|HashMap|Map,key-value，无序的，基于Hash查找速度快|
|TreeMap|Map,key-value，按字母顺序排序|
|LinkedHashMap|Map,key-value，保证为插入时的顺序，基于Hash查找速度快，基于链表实现|
|===
