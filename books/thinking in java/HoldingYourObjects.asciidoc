= Holding Your Objects
:imagesDir: images

== Adding groups of elements

[source,java]
----
Collection<Integer> collection = new ArrayList<Integer>(Arrays.asList(1,2,3,4,5)); // <1> <2>

Collections.addAll(collection, 1,2,3,4,5); // <3>
----
<1> 使用构造函数装入其它 _Collection_
<2> _Arrays.asList_ 将数组转为固定数组的集合
<3> _Collections.addAll()_　为集合添加元素

[IMPORTANT]
====
_Arrays.asList()_ 返回的是一个固定长度的数组集合，其继承了AbstractList，其内部维持了一个固定的数组。
由于它没有重写父类的 _add_ 与　_remove_ 方法，所以 _Arrays.asList()_ 返回的 _List_ 调用 _add_ 或 _remove_ 方法将会出现错误。

.见 _Arrays_ 的嵌套类 _ArrayList_
image::ArraysAsList.png[]
====

=== Arrays.asList

[source,java]
----
package holding;//: holding/AsListInference.java
// Arrays.asList() makes its best guess about type.

import java.util.*;

class Snow {
}

class Powder extends Snow {
}

class Light extends Powder {
}

class Heavy extends Powder {
}

class Crusty extends Snow {
}

class Slush extends Snow {
}

public class AsListInference {
    public static void main(String[] args) {
        List<Snow> snow1 = Arrays.asList(
                new Crusty(), new Slush(), new Powder());

        // Won't compile:
        // List<Snow> snow2 = Arrays.asList( // <1>
        //   new Light(), new Heavy());
        // Compiler says:
        // found   : java.util.List<Powder>
        // required: java.util.List<Snow>

        // Collections.addAll() doesn't get confused:
        List<Snow> snow3 = new ArrayList<Snow>();
        Collections.addAll(snow3, new Light(), new Heavy()); // <2>

        // Give a hint using an
        // explicit type argument specification:
        List<Snow> snow4 = Arrays.<Snow>asList( // <3>
                new Light(), new Heavy());

        snow4.add(new Powder()); // <4>
    }
} ///:~
----
<1> 这里不能编译，父类 _Powder_ 不自动向上转型为 _Snow_
<2> 使用 _Collections.addAll()_ 不会存在 (1) 中的问题
<3> 使用 *Arrays.<Snow>asList* 可以强制转型
<4> 这里调用失败，不能给 _Arrays.asList()_ 返回的集合 _add_ 或 _remove_ 元素。

[source,java]
----
Exception in thread "main" java.lang.UnsupportedOperationException
	at java.util.AbstractList.add(AbstractList.java:131)
	at java.util.AbstractList.add(AbstractList.java:91)
	at holding.AsListInference.main(AsListInference.java:45)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
----

== Printing containers
_Array_ 使用 _Arrays.toString()_ 来输入一个可阅读的数组值。
而 _Map_ 或 _List_ 则可以直接输出，因为它们的父类重写了 _toString()_ 。

[source,java]
----
package holding;//: holding/PrintingContainers.java
// Containers print themselves automatically.

import java.util.*;

import static net.mindview.util.Print.*;

public class PrintingContainers {
    static Collection fill(Collection<String> collection) {
        collection.add("rat");
        collection.add("cat");
        collection.add("dog");
        collection.add("dog");
        return collection;
    }

    static Map fill(Map<String, String> map) {
        map.put("rat", "Fuzzy");
        map.put("cat", "Rags");
        map.put("dog", "Bosco");
        map.put("dog", "Spot");
        return map;
    }

    public static void main(String[] args) {
        print(fill(new ArrayList<String>()));
        print(fill(new LinkedList<String>()));
        print(fill(new HashSet<String>()));
        print(fill(new TreeSet<String>()));
        print(fill(new LinkedHashSet<String>()));
        print(fill(new HashMap<String, String>()));
        print(fill(new TreeMap<String, String>()));
        print(fill(new LinkedHashMap<String, String>()));
    }
} /* Output:
[rat, cat, dog, dog]
[rat, cat, dog, dog]
[dog, cat, rat]
[cat, dog, rat]
[rat, cat, dog]
{dog=Spot, cat=Rags, rat=Fuzzy}
{cat=Rags, dog=Spot, rat=Fuzzy}
{rat=Fuzzy, cat=Rags, dog=Spot}
*///:~
----

._AbstractMap_ 中重写了 _toString()_
[source,java]
----
    public String toString() {
	Iterator<Entry<K,V>> i = entrySet().iterator();
	if (! i.hasNext())
	    return "{}";

	StringBuilder sb = new StringBuilder();
	sb.append('{');
	for (;;) {
	    Entry<K,V> e = i.next();
	    K key = e.getKey();
	    V value = e.getValue();
	    sb.append(key   == this ? "(this Map)" : key);
	    sb.append('=');
	    sb.append(value == this ? "(this Map)" : value);
	    if (! i.hasNext())  // <1>
		return sb.append('}').toString();
	    sb.append(", ");
	}
    }
----
<1> 通过前面判断来阻止最后追加 `,`

._AbstractCollection_
[source,java]
----
    public String toString() {
        Iterator<E> i = iterator();
	if (! i.hasNext())
	    return "[]";

	StringBuilder sb = new StringBuilder();
	sb.append('[');
	for (;;) {
	    E e = i.next();
	    sb.append(e == this ? "(this Collection)" : e);
	    if (! i.hasNext())
		return sb.append(']').toString();
	    sb.append(", ");
	}
    }
----

image::Collections.png[]

|===
|名称|说明|
|ArrayList|List，按插入顺序输出。List是不去重复的，基于数组实现。|
|LinkedList|List,按插入顺序输出。保证为插入时的顺序，基于链表实现。|
|HashSet|Set,去重复的，无序，基于Hash查找速度快|
|TreeSet|Set,去重复的，按字母顺序排序|
|LinkedHashSet|Set,去重复的，保证为插入时的顺序，基于链表实现|
|HashMap|Map,key-value，无序的，基于Hash查找速度快|
|TreeMap|Map,key-value，按字母顺序排序|
|LinkedHashMap|Map,key-value，保证为插入时的顺序，基于Hash查找速度快，基于链表实现|
|===

== List

_List_ 接口在 _Collection_ 接口之上又添加了一些方法。

.这里有两种基本的 _List_ 实现类：
ArrayList:: 擅长随机访问元素，但是不适合在集合中间添加或删除元素。　因为它基于数组实现
LinkedList:: 不擅长随机访问元素，适合在集合中添加或删除元素。 因为它基于链表实现

.示例
[source,java]
----
package holding;//: holding/ListFeatures.java

import typeinfo.pets.*;

import java.util.*;

import static net.mindview.util.Print.*;

public class ListFeatures {
    public static void main(String[] args) {
        Random rand = new Random(47);
        List<Pet> pets = Pets.arrayList(7);
        print("1: " + pets);
        Hamster h = new Hamster();
        pets.add(h); // Automatically resizes
        print("2: " + pets);
        print("3: " + pets.contains(h));
        pets.remove(h); // Remove by object
        Pet p = pets.get(2);
        print("4: " + p + " " + pets.indexOf(p));
        Pet cymric = new Cymric();
        print("5: " + pets.indexOf(cymric));
        print("6: " + pets.remove(cymric));
        // Must be the exact object:
        print("7: " + pets.remove(p));
        print("8: " + pets);
        pets.add(3, new Mouse()); // Insert at an index
        print("9: " + pets);
        List<Pet> sub = pets.subList(1, 4);
        print("subList: " + sub);
        print("10: " + pets.containsAll(sub));
        Collections.sort(sub); // In-place sort
        print("sorted subList: " + sub);
        // Order is not important in containsAll():
        print("11: " + pets.containsAll(sub));
        Collections.shuffle(sub, rand); // Mix it up
        print("shuffled subList: " + sub);
        print("12: " + pets.containsAll(sub));
        List<Pet> copy = new ArrayList<Pet>(pets);
        sub = Arrays.asList(pets.get(1), pets.get(4));
        print("sub: " + sub);
        copy.retainAll(sub);
        print("13: " + copy);
        copy = new ArrayList<Pet>(pets); // Get a fresh copy
        copy.remove(2); // Remove by index
        print("14: " + copy);
        copy.removeAll(sub); // Only removes exact objects
        print("15: " + copy);
        copy.set(1, new Mouse()); // Replace an element
        print("16: " + copy);
        copy.addAll(2, sub); // Insert a list in the middle
        print("17: " + copy);
        print("18: " + pets.isEmpty());
        pets.clear(); // Remove all elements
        print("19: " + pets);
        print("20: " + pets.isEmpty());
        pets.addAll(Pets.arrayList(4));
        print("21: " + pets);
        Object[] o = pets.toArray();
        print("22: " + o[3]);
        Pet[] pa = pets.toArray(new Pet[0]);
        print("23: " + pa[3].id());
    }
} /* Output:
1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]
2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]
3: true
4: Cymric 2
5: -1
6: false
7: true
8: [Rat, Manx, Mutt, Pug, Cymric, Pug]
9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]
subList: [Manx, Mutt, Mouse]
10: true
sorted subList: [Manx, Mouse, Mutt]
11: true
shuffled subList: [Mouse, Manx, Mutt]
12: true
sub: [Mouse, Pug]
13: [Mouse, Pug]
14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]
15: [Rat, Mutt, Cymric, Pug]
16: [Rat, Mouse, Cymric, Pug]
17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]
18: false
19: []
20: true
21: [Manx, Cymric, Rat, EgyptianMau]
22: EgyptianMau
23: 14
*///:~
----

.主要方法说明
|===
|方法|说明|
|contains|检查集合中是否存在元素|
|remove|移除指定元素，必须与集合中的元素 equals 为 _true_ 哦|
|indexOf||
|subList||
|containsAll||
|Collections.shuffle|洗牌，打散集合中元素的顺序|
|retainAll|只保留指定 _subList_ 中的元素，也就是非 _subList_ 中的元素则移除|
|removeAll||
|addAll||
|pets.toArray(new Pet[0])|看 _toArray_ 的实现，此处指定数组长度为0时，实际上是重新 _new_ 了一个数组|
|===

== Iterator
_Iterator_ 提供了对 _Containers_ 的统一访问，使得调用者不再需要关心具体的 _Container_ 实现。

_Java_ *Iterator* 只能朝一个方向移动（遍历）。

.使用 _Iterator_　可进行的操作
. 使用 _Collection_ 的 _iterator()_ 方法返回一个 _Iterator_ 对象
. 获取序列中的下一对象，调用 _Iterator_ 的 _next()_ 方法
. 查看是否有下一对象时，使用 _hasNext()_ 方法
. 移除最后获得的对象，使用 _remove()_ 方法

.示例
[source,java]
----
package holding;//: holding/SimpleIteration.java

import typeinfo.pets.*;

import java.util.*;

public class SimpleIteration {
    public static void main(String[] args) {
        List<Pet> pets = Pets.arrayList(12);
        Iterator<Pet> it = pets.iterator();
        while (it.hasNext()) {
            Pet p = it.next();
            System.out.print(p.id() + ":" + p + " ");
        }
        System.out.println();
        // A simpler approach, when possible:
        for (Pet p : pets) // <1>
            System.out.print(p.id() + ":" + p + " ");
        System.out.println();
        // An Iterator can also remove elements:
        it = pets.iterator();
        for (int i = 0; i < 6; i++) {
            it.next();
            it.remove();
        }
        System.out.println(pets);
    }
} /* Output:
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster
0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster
[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]
*///:~
----
<1> _foreach_ 写法，实际上也是调用 _iterator_ 实现的。所以它只能遍历实现了 _Iterator_ 接口的 _container_

[NOTE]
====
_remove()_ 方法是可选的，即不是所有的 *Iterator* 实现类都需要实现该方法。

不过 _JDK_ 中的 _container_ 都实现了该方法。
====

=== ListIterator
*ListIterator* 是 _List_ 专有的一个 _Iterator_　的子接口，通过调用 _listIterator()_ 获得。

_Iterator_ 只能向 _next_ 遍历，而 *ListIterator* 则可以向 _previous_ 遍历。

.ListIteration
[source,java]
----
package holding;//: holding/ListIteration.java

import typeinfo.pets.*;

import java.util.*;

public class ListIteration {
    public static void main(String[] args) {
        List<Pet> pets = Pets.arrayList(8);
        ListIterator<Pet> it = pets.listIterator();
        while (it.hasNext())
            System.out.print(it.next() + ", " + it.nextIndex() +
                    ", " + it.previousIndex() + "; ");
        System.out.println();
        // Backwards:
        while (it.hasPrevious())
            System.out.print(it.previous().id() + " ");
        System.out.println();
        System.out.println(pets);
        it =   pets.listIterator(3); // <1>
        while (it.hasNext()) {
            it.next();
            it.set(Pets.randomPet()); // <2>
        }
        System.out.println(pets);
    }
} /* Output:
Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;
7 6 5 4 3 2 1 0
[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]
[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]
*///:~
----
<1> 该方法的一个重载，详见文档说明。这里表示从索引位置为 _3_ 处开始向 _next_ 或 _previous_ 遍历。
<2> 同时还有 _set_ 方法，来直接修改 _List_ 中的对象

== LinkedList
_LinkedList_ 同 _ArrayList_ 一样实现了抽象接口 _List_ ，但是它在执行往集合中间添加或移除数据时比 _ArrayList_ 更方便且性能消耗小很多，相反，在随机访问元素上比不过 _ArrayList_ 。

_LinkedList_　添加了一些方法，使它可以像 _Stack_ _Queue_ 或 _双出口的 Queue_ 使用。

.Queue接口
|===
|方法|说明|
|add|插入元素至队列尾部|
|offer|插入元素至队列尾部，当使用容量有限制的队列时，此方法比 _add_ 更好|
|poll|获取并移除队列头部元素，如果队列为空，将返回 _null_|
|element|获取但是不移除队列头部元素，如果队列为空，将抛出异常|
|peek|获取但是不移除队列头部元素，如果队列为空，将返回 _null_|
|===

.LinkedList获取元素操作
|===
|方法|名称|
|getFirst|取得队列头部元素，如果队列为空，将抛出 _NoSuchElementException_ |
|element|取得队列头部元素，如果队列为空，将抛出 _NoSuchElementException_ |
|peek|取得队列头部元素，如果队列为空，将返回 _null_ |
|===

.LinkedList移除元素操作
|===
|方法|名称|
|remove|获取队列头部元素并移除，如果队列为空，将抛出 _NoSuchElementException_|
|removeFirst|等同于 _remove_ |
|pool|获取队列头部元素并移除，如果队列为空，将返回 _null_ |
|removeLast|获取并移除队列尾部的元素|
|===

.LinkedList添加元素操作
|===
|方法|名称|
|addFirst|添加元素至队列头部|
|add|添加元素至队列尾部|
|addLast|等同于 _add_ |
|offer|等同于 _add_ |
|===

.LinkedListFeatures
[source,java]
----
package holding;//: holding/LinkedListFeatures.java

import typeinfo.pets.*;

import java.util.*;

import static net.mindview.util.Print.*;

public class LinkedListFeatures {
    public static void main(String[] args) {
        LinkedList<Pet> pets =
                new LinkedList<Pet>(Pets.arrayList(5));
        print(pets);
        // Identical:
        print("pets.getFirst(): " + pets.getFirst());
        print("pets.element(): " + pets.element());
        // Only differs in empty-list behavior:
        print("pets.peek(): " + pets.peek());
        // Identical; remove and return the first element:
        print("pets.remove(): " + pets.remove());
        print("pets.removeFirst(): " + pets.removeFirst());
        // Only differs in empty-list behavior:
        print("pets.poll(): " + pets.poll());
        print(pets);
        pets.addFirst(new Rat());
        print("After addFirst(): " + pets);
        pets.offer(Pets.randomPet());
        print("After offer(): " + pets);
        pets.add(Pets.randomPet());
        print("After add(): " + pets);
        pets.addLast(new Hamster());
        print("After addLast(): " + pets);
        print("pets.removeLast(): " + pets.removeLast());
    }
} /* Output:
[Rat, Manx, Cymric, Mutt, Pug]
pets.getFirst(): Rat
pets.element(): Rat
pets.peek(): Rat
pets.remove(): Rat
pets.removeFirst(): Manx
pets.poll(): Cymric
[Mutt, Pug]
After addFirst(): [Rat, Mutt, Pug]
After offer(): [Rat, Mutt, Pug, Cymric]
After add(): [Rat, Mutt, Pug, Cymric, Pug]
After addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]
pets.removeLast(): Hamster
*///:~
----

== Stack
_Stack_ 经常被称为 *"last-in,first-out"* 的 _container_ ，也被称为 _push down_ 栈，向下存储。因为你最后放入的元素，将会是第一个被你弹出的元素。

_LinkedList_ 中有相关的方法直接实现了 _Stack_ 的功能，所以你甚至可以直接使用 _LinkedList_ 当作 _Stack_ 使用。然而有时候， _Stack_ 更有语义一些。

image::stackQueue.png[]
