= Holding Your Objects
:imagesDir: images

== Adding groups of elements

[source,java]
----
Collection<Integer> collection = new ArrayList<Integer>(Arrays.asList(1,2,3,4,5)); // <1> <2>

Collections.addAll(collection, 1,2,3,4,5); // <3>
----
<1> 使用构造函数装入其它 _Collection_
<2> _Arrays.asList_ 将数组转为固定数组的集合
<3> _Collections.addAll()_　为集合添加元素

[IMPORTANT]
====
_Arrays.asList()_ 返回的是一个固定长度的数组集合，其继承了AbstractList，其内部维持了一个固定的数组。
由于它没有重写父类的 _add_ 与　_remove_ 方法，所以 _Arrays.asList()_ 返回的 _List_ 调用 _add_ 或 _remove_ 方法将会出现错误。

.见 _Arrays_ 的嵌套类 _ArrayList_
image::ArraysAsList.png[]
====

=== Arrays.asList

[source,java]
----
package holding;//: holding/AsListInference.java
// Arrays.asList() makes its best guess about type.

import java.util.*;

class Snow {
}

class Powder extends Snow {
}

class Light extends Powder {
}

class Heavy extends Powder {
}

class Crusty extends Snow {
}

class Slush extends Snow {
}

public class AsListInference {
    public static void main(String[] args) {
        List<Snow> snow1 = Arrays.asList(
                new Crusty(), new Slush(), new Powder());

        // Won't compile:
        // List<Snow> snow2 = Arrays.asList( // <1>
        //   new Light(), new Heavy());
        // Compiler says:
        // found   : java.util.List<Powder>
        // required: java.util.List<Snow>

        // Collections.addAll() doesn't get confused:
        List<Snow> snow3 = new ArrayList<Snow>();
        Collections.addAll(snow3, new Light(), new Heavy()); // <2>

        // Give a hint using an
        // explicit type argument specification:
        List<Snow> snow4 = Arrays.<Snow>asList( // <3>
                new Light(), new Heavy());

        snow4.add(new Powder()); // <4>
    }
} ///:~
----
<1> 这里不能编译，父类 _Powder_ 不自动向上转型为 _Snow_
<2> 使用 _Collections.addAll()_ 不会存在 (1) 中的问题
<3> 使用 *Arrays.<Snow>asList* 可以强制转型
<4> 这里调用失败，不能给 _Arrays.asList()_ 返回的集合 _add_ 或 _remove_ 元素。

[source,java]
----
Exception in thread "main" java.lang.UnsupportedOperationException
	at java.util.AbstractList.add(AbstractList.java:131)
	at java.util.AbstractList.add(AbstractList.java:91)
	at holding.AsListInference.main(AsListInference.java:45)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
----

== Printing containers
_Array_ 使用 _Arrays.toString()_ 来输入一个可阅读的数组值。
而 _Map_ 或 _List_ 则可以直接输出，因为它们的父类重写了 _toString()_ 。

[source,java]
----
package holding;//: holding/PrintingContainers.java
// Containers print themselves automatically.

import java.util.*;

import static net.mindview.util.Print.*;

public class PrintingContainers {
    static Collection fill(Collection<String> collection) {
        collection.add("rat");
        collection.add("cat");
        collection.add("dog");
        collection.add("dog");
        return collection;
    }

    static Map fill(Map<String, String> map) {
        map.put("rat", "Fuzzy");
        map.put("cat", "Rags");
        map.put("dog", "Bosco");
        map.put("dog", "Spot");
        return map;
    }

    public static void main(String[] args) {
        print(fill(new ArrayList<String>()));
        print(fill(new LinkedList<String>()));
        print(fill(new HashSet<String>()));
        print(fill(new TreeSet<String>()));
        print(fill(new LinkedHashSet<String>()));
        print(fill(new HashMap<String, String>()));
        print(fill(new TreeMap<String, String>()));
        print(fill(new LinkedHashMap<String, String>()));
    }
} /* Output:
[rat, cat, dog, dog]
[rat, cat, dog, dog]
[dog, cat, rat]
[cat, dog, rat]
[rat, cat, dog]
{dog=Spot, cat=Rags, rat=Fuzzy}
{cat=Rags, dog=Spot, rat=Fuzzy}
{rat=Fuzzy, cat=Rags, dog=Spot}
*///:~
----

._AbstractMap_ 中重写了 _toString()_
[source,java]
----
    public String toString() {
	Iterator<Entry<K,V>> i = entrySet().iterator();
	if (! i.hasNext())
	    return "{}";

	StringBuilder sb = new StringBuilder();
	sb.append('{');
	for (;;) {
	    Entry<K,V> e = i.next();
	    K key = e.getKey();
	    V value = e.getValue();
	    sb.append(key   == this ? "(this Map)" : key);
	    sb.append('=');
	    sb.append(value == this ? "(this Map)" : value);
	    if (! i.hasNext())  // <1>
		return sb.append('}').toString();
	    sb.append(", ");
	}
    }
----
<1> 通过前面判断来阻止最后追加 `,`

._AbstractCollection_
[source,java]
----
    public String toString() {
        Iterator<E> i = iterator();
	if (! i.hasNext())
	    return "[]";

	StringBuilder sb = new StringBuilder();
	sb.append('[');
	for (;;) {
	    E e = i.next();
	    sb.append(e == this ? "(this Collection)" : e);
	    if (! i.hasNext())
		return sb.append(']').toString();
	    sb.append(", ");
	}
    }
----

image::Collections.png[]

|===
|名称|说明|
|ArrayList|List，按插入顺序输出。List是不去重复的，基于数组实现。|
|LinkedList|List,按插入顺序输出。保证为插入时的顺序，基于链表实现。|
|HashSet|Set,去重复的，无序，基于Hash查找速度快|
|TreeSet|Set,去重复的，按字母顺序排序|
|LinkedHashSet|Set,去重复的，保证为插入时的顺序，基于链表实现|
|HashMap|Map,key-value，无序的，基于Hash查找速度快|
|TreeMap|Map,key-value，按字母顺序排序|
|LinkedHashMap|Map,key-value，保证为插入时的顺序，基于Hash查找速度快，基于链表实现|
|===

== List

_List_ 接口在 _Collection_ 接口之上又添加了一些方法。

.这里有两种基本的 _List_ 实现类：
ArrayList:: 擅长随机访问元素，但是不适合在集合中间添加或删除元素。　因为它基于数组实现
LinkedList:: 不擅长随机访问元素，适合在集合中添加或删除元素。 因为它基于链表实现

.示例
[source,java]
----
package holding;//: holding/ListFeatures.java

import typeinfo.pets.*;

import java.util.*;

import static net.mindview.util.Print.*;

public class ListFeatures {
    public static void main(String[] args) {
        Random rand = new Random(47);
        List<Pet> pets = Pets.arrayList(7);
        print("1: " + pets);
        Hamster h = new Hamster();
        pets.add(h); // Automatically resizes
        print("2: " + pets);
        print("3: " + pets.contains(h));
        pets.remove(h); // Remove by object
        Pet p = pets.get(2);
        print("4: " + p + " " + pets.indexOf(p));
        Pet cymric = new Cymric();
        print("5: " + pets.indexOf(cymric));
        print("6: " + pets.remove(cymric));
        // Must be the exact object:
        print("7: " + pets.remove(p));
        print("8: " + pets);
        pets.add(3, new Mouse()); // Insert at an index
        print("9: " + pets);
        List<Pet> sub = pets.subList(1, 4);
        print("subList: " + sub);
        print("10: " + pets.containsAll(sub));
        Collections.sort(sub); // In-place sort
        print("sorted subList: " + sub);
        // Order is not important in containsAll():
        print("11: " + pets.containsAll(sub));
        Collections.shuffle(sub, rand); // Mix it up
        print("shuffled subList: " + sub);
        print("12: " + pets.containsAll(sub));
        List<Pet> copy = new ArrayList<Pet>(pets);
        sub = Arrays.asList(pets.get(1), pets.get(4));
        print("sub: " + sub);
        copy.retainAll(sub);
        print("13: " + copy);
        copy = new ArrayList<Pet>(pets); // Get a fresh copy
        copy.remove(2); // Remove by index
        print("14: " + copy);
        copy.removeAll(sub); // Only removes exact objects
        print("15: " + copy);
        copy.set(1, new Mouse()); // Replace an element
        print("16: " + copy);
        copy.addAll(2, sub); // Insert a list in the middle
        print("17: " + copy);
        print("18: " + pets.isEmpty());
        pets.clear(); // Remove all elements
        print("19: " + pets);
        print("20: " + pets.isEmpty());
        pets.addAll(Pets.arrayList(4));
        print("21: " + pets);
        Object[] o = pets.toArray();
        print("22: " + o[3]);
        Pet[] pa = pets.toArray(new Pet[0]);
        print("23: " + pa[3].id());
    }
} /* Output:
1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]
2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]
3: true
4: Cymric 2
5: -1
6: false
7: true
8: [Rat, Manx, Mutt, Pug, Cymric, Pug]
9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]
subList: [Manx, Mutt, Mouse]
10: true
sorted subList: [Manx, Mouse, Mutt]
11: true
shuffled subList: [Mouse, Manx, Mutt]
12: true
sub: [Mouse, Pug]
13: [Mouse, Pug]
14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]
15: [Rat, Mutt, Cymric, Pug]
16: [Rat, Mouse, Cymric, Pug]
17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]
18: false
19: []
20: true
21: [Manx, Cymric, Rat, EgyptianMau]
22: EgyptianMau
23: 14
*///:~
----

.主要方法说明
|===
|方法|说明|
|contains|检查集合中是否存在元素|
|remove|移除指定元素，必须与集合中的元素 equals 为 _true_ 哦|
|indexOf||
|subList||
|containsAll||
|Collections.shuffle|洗牌，打散集合中元素的顺序|
|retainAll|只保留指定 _subList_ 中的元素，也就是非 _subList_ 中的元素则移除|
|removeAll||
|addAll||
|pets.toArray(new Pet[0])|看 _toArray_ 的实现，此处指定数组长度为0时，实际上是重新 _new_ 了一个数组|
|===